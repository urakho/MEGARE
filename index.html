<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Retro Tanks - Procedural Walls</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background: #1a1a1a; 
            font-family: 'Courier New', Courier, monospace; 
            display: flex; 
            justify-content: center; 
            align-items: center; 
            height: 100vh; 
        }
        canvas { 
            background: #445522; 
            border: 8px solid #333; 
            box-shadow: 0 0 50px rgba(0,0,0,0.8);
            image-rendering: pixelated;
        }
        .ui { 
            position: absolute; 
            top: 20px; 
            left: 20px; 
            color: #fff; 
            background: rgba(0,0,0,0.7); 
            padding: 15px; 
            border: 2px solid #555;
            pointer-events: none; 
            line-height: 1.5;
        }
        b { color: #ffcc00; }
    </style>
</head>
<body>

<div class="ui">
    <b>WASD</b> ‚Äî –•–æ–¥ —Ç–∞–Ω–∫–∞<br>
    <b>WHEEL</b> ‚Äî –í—Ä–∞—â–µ–Ω–∏–µ –±–∞—à–Ω–∏<br>
    <b>SPACE</b> ‚Äî –í—ã—Å—Ç—Ä–µ–ª<br>
    <b>F5</b> ‚Äî –ü–µ—Ä–µ–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –º–∏—Ä<br>
    <b>Coins: <span id="coinDisplay">0</span></b><br>
    <hr>
    <small>–°—Ç–µ–Ω—ã —Å–æ–∑–¥–∞—é—Ç—Å—è —Å–µ–≥–º–µ–Ω—Ç–∞–º–∏,<br>–ø—Ä–æ–µ–∑–¥ –≤—Å–µ–≥–¥–∞ —Å–≤–æ–±–æ–¥–µ–Ω.</small>
</div>
<canvas id="gameCanvas"></canvas>

<!-- Main menu overlay -->
<div id="mainMenu" style="position: absolute; inset: 0; display:flex; align-items:center; justify-content:center; z-index:10;">
    <div style="background: rgba(0,0,0,0.88); padding: 28px; border: 2px solid #666; text-align:center; color:#fff; width:440px; border-radius:8px;">
        <h1 style="margin:6px 0 14px 0; font-size:28px;">–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é</h1>
        <div id="previewWrap" style="display:flex;flex-direction:column;align-items:center;">
            <canvas id="previewCanvas" width="200" height="150" style="background:#2b5a2b; border:2px solid #444; border-radius:4px;"></canvas>
            <div id="previewLabel" style="margin-top:10px; font-size:16px; font-weight:600;">–í–∞—à —Ç–∞–Ω–∫</div>
        </div>
        <button id="startBtn" style="margin-top:16px; padding:12px 22px; font-size:18px; cursor:pointer; border-radius:6px;">START</button>
        <button id="shopBtn" style="margin-top:8px; padding:12px 22px; font-size:18px; cursor:pointer; border-radius:6px;">–ú–∞–≥–∞–∑–∏–Ω</button>
        <button id="characterBtn" style="margin-top:8px; padding:12px 22px; font-size:18px; cursor:pointer; border-radius:6px;">–ü–µ—Ä—Å–æ–Ω–∞–∂–∏</button>
    </div>
</div>

<!-- Mode selection modal (hidden by default) -->
<div id="modeModal" style="position: absolute; inset: 0; display:none; align-items:center; justify-content:center; z-index:11;">
    <div style="background: rgba(0,0,0,0.95); padding: 22px; border: 2px solid #666; text-align:center; color:#fff; width:520px; border-radius:8px;">
        <h2 style="margin:6px 0 12px 0; font-size:22px;">–í—ã–±–µ—Ä–∏—Ç–µ —Ä–µ–∂–∏–º</h2>
        <div style="display:flex; flex-direction:column; gap:12px; align-items:center;">
            <button id="modeSingle" style="padding:10px 18px; width:80%; font-size:16px;">–û–¥–∏–Ω–æ—á–Ω—ã–π —Ä–µ–∂–∏–º</button>
            <button id="modeTeam" style="padding:10px 18px; width:80%; font-size:16px;">–ö–æ–º–∞–Ω–¥–Ω—ã–π —Ä–µ–∂–∏–º (4 –∫–æ–º–∞–Ω–¥—ã –ø–æ 2)</button>
            <button id="modeCancel" style="padding:10px 18px; width:80%; font-size:16px;">–û—Ç–º–µ–Ω–∞</button>
        </div>
    </div>
</div>

<!-- Shop modal (hidden by default) -->
<div id="shopModal" style="position: absolute; inset: 0; display:none; align-items:center; justify-content:center; z-index:12;">
    <div style="background: linear-gradient(135deg, #2c3e50, #34495e); padding: 30px; border: 4px solid #f39c12; text-align:center; color:#fff; width:600px; border-radius:15px; box-shadow: 0 0 20px rgba(0,0,0,0.8);">
        <h2 style="margin:0 0 20px 0; font-size:28px; color:#f39c12;">üõí –ú–∞–≥–∞–∑–∏–Ω</h2>
        <div style="display:flex; flex-direction:column; gap:15px; align-items:center;">
            <div style="background: rgba(255,255,255,0.1); padding:15px; border-radius:10px; width:80%;">
                <img src="png/cont1.png" alt="–ö–æ–Ω—Ç–µ–π–Ω–µ—Ä" style="width:80px; height:80px; margin-bottom:10px;">
                <p style="margin:5px 0; font-size:16px;">–ö–æ–Ω—Ç–µ–π–Ω–µ—Ä —Å —Å–ª—É—á–∞–π–Ω—ã–º —Ü–≤–µ—Ç–æ–º —Ç–∞–Ω–∫–∞</p>
                <button id="buyContainer" style="padding:10px 20px; font-size:16px; background:#e74c3c; color:white; border:none; border-radius:8px; cursor:pointer;">–ö—É–ø–∏—Ç—å (100 –º–æ–Ω–µ—Ç)</button>
            </div>
            <div style="background: rgba(255,255,255,0.1); padding:15px; border-radius:10px; width:80%;">
                <img src="png/super-cont.png" alt="–°—É–ø–µ—Ä –ö–æ–Ω—Ç–µ–π–Ω–µ—Ä" style="width:80px; height:80px; margin-bottom:10px;">
                <p style="margin:5px 0; font-size:16px;">–°—É–ø–µ—Ä –ö–æ–Ω—Ç–µ–π–Ω–µ—Ä —Å —Ä–µ–¥–∫–∏–º–∏ –±–æ–Ω—É—Å–∞–º–∏</p>
                <button id="buySuperContainer" style="padding:10px 20px; font-size:16px; background:#9b59b6; color:white; border:none; border-radius:8px; cursor:pointer;">–ö—É–ø–∏—Ç—å (200 –º–æ–Ω–µ—Ç)</button>
            </div>
            <button id="shopCancel" style="padding:12px 25px; font-size:16px; background:#95a5a6; color:white; border:none; border-radius:8px; cursor:pointer; margin-top:10px;">–ó–∞–∫—Ä—ã—Ç—å</button>
        </div>
    </div>
</div>

<!-- Character modal (hidden by default) -->
<div id="characterModal" style="position: absolute; inset: 0; display:none; align-items:center; justify-content:center; z-index:13;">
    <div style="background: linear-gradient(135deg, #34495e, #2c3e50); padding: 30px; border: 4px solid #f39c12; text-align:center; color:#fff; width:600px; border-radius:15px; box-shadow: 0 0 20px rgba(0,0,0,0.8);">
        <h2 style="margin:0 0 20px 0; font-size:28px; color:#f39c12;">üë§ –ü–µ—Ä—Å–æ–Ω–∞–∂–∏</h2>
        <div style="display:flex; flex-direction:row; flex-wrap:wrap; gap:20px; align-items:center; justify-content:center;">
            <div style="text-align:center; width:180px;">
                <canvas id="normalTankPreview" width="150" height="150" style="border:2px solid #e74c3c; border-radius:8px;"></canvas>
                <button id="selectNormalTank" style="padding:10px 20px; font-size:16px; background:#e74c3c; color:white; border:none; border-radius:8px; cursor:pointer; margin-top:10px;">–û–±—ã—á–Ω—ã–π —Ç–∞–Ω–∫</button>
            </div>
            <div style="text-align:center; width:180px;">
                <canvas id="iceTankPreview" width="150" height="150" style="border:2px solid #3498db; border-radius:8px;"></canvas>
                <button id="selectIceTank" style="padding:10px 20px; font-size:16px; background:#3498db; color:white; border:none; border-radius:8px; cursor:pointer; margin-top:10px;">–õ–µ–¥—è–Ω–æ–π —Ç–∞–Ω–∫</button>
            </div>
            <div style="text-align:center; width:180px;">
                <canvas id="fireTankPreview" width="150" height="150" style="border:2px solid #e67e22; border-radius:8px;"></canvas>
                <button id="selectFireTank" style="padding:10px 20px; font-size:16px; background:#e67e22; color:white; border:none; border-radius:8px; cursor:pointer; margin-top:10px;">–û–≥–Ω–µ–º—ë—Ç—á–∏–∫</button>
            </div>
            <div style="text-align:center; width:180px;">
                <canvas id="buratinoTankPreview" width="150" height="150" style="border:2px solid #9b59b6; border-radius:8px;"></canvas>
                <button id="selectBuratinoTank" style="padding:10px 20px; font-size:16px; background:#9b59b6; color:white; border:none; border-radius:8px; cursor:pointer; margin-top:10px;">–ë—É—Ä–∞—Ç–∏–Ω–æ</button>
            </div>
                <div style="text-align:center; width:180px;">
                    <canvas id="toxicTankPreview" width="150" height="150" style="border:2px solid #00ff9da0; border-radius:8px;"></canvas>
                    <button id="selectToxicTank" style="padding:10px 20px; font-size:16px; background:#00ff9da0; color:white; border:none; border-radius:8px; cursor:pointer; margin-top:10px;">–û—Ç—Ä–∞–≤–ª—è—é—â–∏–π</button>
                </div>
        </div>
        <button id="characterCancel" style="padding:12px 25px; font-size:16px; background:#95a5a6; color:white; border:none; border-radius:8px; cursor:pointer; margin-top:20px;">–ó–∞–∫—Ä—ã—Ç—å</button>
    </div>
</div>

<script>
/**
 * –ö–õ–ê–°–°–ò–ß–ï–°–ö–ò–ï –¢–ê–ù–ö–ò –° –ü–†–û–¶–ï–î–£–†–ù–´–ú–ò –°–¢–ï–ù–ê–ú–ò
 * –õ–æ–≥–∏–∫–∞: –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –¥–ª–∏–Ω–Ω—ã—Ö –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏–π —Å –ø—Ä–æ–≤–µ—Ä–∫–æ–π –ø—É—Ç–µ–π
 */

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
// Display size (canvas kept reasonable for performance)
const DISPLAY_W = 900, DISPLAY_H = 700;
canvas.width = DISPLAY_W;
canvas.height = DISPLAY_H;
// World size (can be larger than display for big maps like War)
let worldWidth = DISPLAY_W, worldHeight = DISPLAY_H;

// –ì–ª–æ–±–∞–ª—å–Ω–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ
const keys = {};
let objects = [];
let particles = [];
let bullets = [];
let flames = [];
let enemies = [];
let allies = [];
let gameState = 'menu';
let currentMode = 'menu';
// –í—Ä–µ–º–µ–Ω–Ω–∞—è –æ—Ç–ª–∞–¥–æ—á–Ω–∞—è –∫–æ–ª–ª–µ–∫—Ü–∏—è –ª–∏–Ω–∏–π –¥–ª—è AI (–Ω–µ —Å–æ—Ö—Ä–∞–Ω—è–µ—Ç—Å—è)
let debugLines = [];
// –ü–æ–∫–∞–∑–∞—Ç—å –æ—Ç–ª–∞–¥–æ—á–Ω—ã–µ –ª–∏–Ω–∏–∏ AI (true ‚Äî –ø–æ–∫–∞–∑–∞—Ç—å –æ—Ç–ª–∞–¥–æ—á–Ω—ã–µ —Ç—Ä–∞—Å—Å—ã)
const SHOW_AI_DEBUG = false;

// –ù–∞–≤–∏–≥–∞—Ü–∏–æ–Ω–Ω–∞—è —Å–µ—Ç–∫–∞ –¥–ª—è A* (–ø–µ—Ä–µ—Å—Ç—Ä–∞–∏–≤–∞–µ—Ç—Å—è –ø—Ä–∏ –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏–∏ —è—â–∏–∫–æ–≤)
let navGrid = null;
let navCols = 0, navRows = 0, navCell = 24;
// –†–∞–∑–º–µ—Ä –∞–≥–µ–Ω—Ç–∞, –∏—Å–ø–æ–ª—å–∑—É–µ–º—ã–π –ø—Ä–∏ –ø–æ—Å—Ç—Ä–æ–µ–Ω–∏–∏ –±–µ–∑–æ–ø–∞—Å–Ω—ã—Ö —è—á–µ–µ–∫
let navAgentW = 38, navAgentH = 38;
let navNeedsRebuild = true;
// War mode team spawn centers (filled by spawnWarMode)
let warTeamSpawns = [];

// –ì–ª–æ–±–∞–ª—å–Ω–∞—è –ø–µ—Ä–µ–∑–∞—Ä—è–¥–∫–∞ –≤ —Ç–∏–∫–∞—Ö (1 —Ç–∏–∫ = 1/60s)
const FIRE_COOLDOWN = 20; // ~333ms at 60fps
// –ë–∞–∑–æ–≤–∞—è –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å —É—Å–ø–µ—à–Ω–æ–≥–æ —É–∫–ª–æ–Ω–µ–Ω–∏—è AI (0..1)
const DODGE_BASE_ACCURACY = 0.8;

// –ì–ª–æ–±–∞–ª—å–Ω–∞—è –≤–∞–ª—é—Ç–∞
let coins = parseInt(localStorage.getItem('tankCoins')) || 0;

// Camera follow flag
let cameraFollow = false;

// –¢–∏–ø —Ç–∞–Ω–∫–∞ –∏–≥—Ä–æ–∫–∞
let tankType = 'normal';

const tank = {
    x: 50,
    y: 50,
    w: 38,
    h: 38,
    speed: 3.2,
    turretAngle: 0,
    baseAngle: 0,
    color: '#0000FF',
    trackOffset: 0,
    hp: 3,
    maxHp: 3,
    team: 0,
    fireCooldown: 0
};

// –°–ª—É—à–∞—Ç–µ–ª–∏ —Å–æ–±—ã—Ç–∏–π
window.onkeydown = (e) => keys[e.code] = true;
window.onkeyup = (e) => keys[e.code] = false;
window.addEventListener('wheel', (e) => {
    tank.turretAngle += e.deltaY * 0.0015;
});

// Preview canvas drawing
const previewCanvas = document.getElementById('previewCanvas');
const previewCtx = previewCanvas && previewCanvas.getContext ? previewCanvas.getContext('2d') : null;
// Character modal previews
const normalTankPreview = document.getElementById('normalTankPreview');
const normalTankCtx = normalTankPreview && normalTankPreview.getContext ? normalTankPreview.getContext('2d') : null;
const iceTankPreview = document.getElementById('iceTankPreview');
const iceTankCtx = iceTankPreview && iceTankPreview.getContext ? iceTankPreview.getContext('2d') : null;
const fireTankPreview = document.getElementById('fireTankPreview');
const fireTankCtx = fireTankPreview && fireTankPreview.getContext ? fireTankPreview.getContext('2d') : null;
const buratinoTankPreview = document.getElementById('buratinoTankPreview');
const buratinoTankCtx = buratinoTankPreview && buratinoTankPreview.getContext ? buratinoTankPreview.getContext('2d') : null;
const toxicTankPreview = document.getElementById('toxicTankPreview');
const toxicTankCtx = toxicTankPreview && toxicTankPreview.getContext ? toxicTankPreview.getContext('2d') : null;
function drawTankOn(ctx, cx, cy, W, H, color, turretAngle, turretScale = 1, type = 'normal') {
    ctx.save();
    ctx.translate(cx, cy);
    if (type === 'fire') {
        W *= 1.2; // make wider
    } else if (type === 'buratino') {
        W *= 1.1; // make longer
    }
    // tracks (top/bottom)
    const trackThick = Math.max(6, W * 0.12);
    ctx.fillStyle = type === 'ice' ? '#F0F8FF' : '#222';
    ctx.fillRect(-W/2, -H/2 - trackThick/2, W, trackThick);
    ctx.fillRect(-W/2, H/2 - trackThick/2, W, trackThick);
    if (type === 'buratino') {
        // track segments
        ctx.strokeStyle = '#444';
        ctx.lineWidth = 1;
        for (let x = -W/2 + 5; x < W/2; x += 10) {
            ctx.beginPath();
            ctx.moveTo(x, -H/2 - trackThick/2);
            ctx.lineTo(x, -H/2 + trackThick/2);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(x, H/2 - trackThick/2);
            ctx.lineTo(x, H/2 + trackThick/2);
            ctx.stroke();
        }
    }
    // body (between tracks)
    ctx.fillStyle = color;
    ctx.fillRect(-W/2 + 2, -H/2 + trackThick/2 + 2, W - 4, H - trackThick - 4);
    if (type === 'fire') {
        // fuel tanks (horizontal on top and bottom)
        ctx.fillStyle = '#CCC';
        const tankWidth = W * 0.8 * (turretScale === 1 ? 0.8 : 1);
        const tankRadius = 4 * (turretScale === 1 ? 0.8 : 1);
        // top tank
        ctx.beginPath();
        ctx.ellipse(0, -H/2 + 3, tankWidth/2, tankRadius, 0, 0, 2 * Math.PI);
        ctx.fill();
        ctx.fillRect(-tankWidth/2, -H/2 + 3 - tankRadius, tankWidth, tankRadius*2);
        ctx.beginPath();
        ctx.ellipse(0, -H/2 + 3, tankWidth/2, tankRadius, 0, Math.PI, 2 * Math.PI);
        ctx.fill();
        // bottom tank
        ctx.beginPath();
        ctx.ellipse(0, H/2 - 3, tankWidth/2, tankRadius, 0, 0, 2 * Math.PI);
        ctx.fill();
        ctx.fillRect(-tankWidth/2, H/2 - 3 - tankRadius, tankWidth, tankRadius*2);
        ctx.beginPath();
        ctx.ellipse(0, H/2 - 3, tankWidth/2, tankRadius, 0, Math.PI, 2 * Math.PI);
        ctx.fill();
    }
    if (type === 'ice') {
        // ice crystals
        ctx.fillStyle = 'rgba(255,255,255,0.9)';
        // crystal 1
        ctx.beginPath();
        ctx.moveTo(-W/3, -H/3);
        ctx.lineTo(-W/3 + 3, -H/3 - 6);
        ctx.lineTo(-W/3 + 6, -H/3);
        ctx.closePath();
        ctx.fill();
        // crystal 2
        ctx.beginPath();
        ctx.moveTo(W/4, -H/4);
        ctx.lineTo(W/4 + 3, -H/4 - 6);
        ctx.lineTo(W/4 + 6, -H/4);
        ctx.closePath();
        ctx.fill();
        // crystal 3
        ctx.beginPath();
        ctx.moveTo(-W/4, H/4);
        ctx.lineTo(-W/4 + 3, H/4 + 6);
        ctx.lineTo(-W/4 + 6, H/4);
        ctx.closePath();
        ctx.fill();
        // crystal 4
        ctx.beginPath();
        ctx.moveTo(W/3, H/3);
        ctx.lineTo(W/3 + 3, H/3 + 6);
        ctx.lineTo(W/3 + 6, H/3);
        ctx.closePath();
        ctx.fill();
        // crystal 5
        ctx.beginPath();
        ctx.moveTo(0, -H/2 + trackThick/2 + 5);
        ctx.lineTo(3, -H/2 + trackThick/2 - 1);
        ctx.lineTo(6, -H/2 + trackThick/2 + 5);
        ctx.closePath();
        ctx.fill();
        // frost lines
        ctx.strokeStyle = 'rgba(255,255,255,0.7)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(-W/2 + 5, -H/2 + trackThick/2 + 5);
        ctx.lineTo(-W/2 + 15, -H/2 + trackThick/2 + 15);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(W/2 - 15, H/2 - trackThick/2 - 5);
        ctx.lineTo(W/2 - 5, H/2 - trackThick/2 - 15);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(-W/2 + 10, H/2 - trackThick/2 - 10);
        ctx.lineTo(-W/2 + 20, H/2 - trackThick/2 - 20);
        ctx.stroke();
    }
    // hatch outline
    ctx.strokeStyle = 'rgba(0,0,0,0.25)'; ctx.strokeRect(-W*0.12, -H*0.12, W*0.24, H*0.24);
    // turret
    ctx.rotate(turretAngle || 0);
    const tSize = Math.min(W, H) * 0.35 * turretScale * ((type === 'normal' && turretScale === 1 ? 1.95 : 1) * (type === 'ice' && turretScale === 1 ? 1.8 : 1) * (type === 'fire' && turretScale === 1 ? 1.6 : 1) * (type === 'buratino' ? 1.5 : 1));
    // Make hull/turret blue for 'fire' type; barrel stays fire-colored below
    ctx.fillStyle = type === 'ice' ? '#E0FFFF' : type === 'fire' ? '#2D8C6C' : type === 'buratino' ? '#9370DB' : '#5c7041';
    ctx.fillRect(-tSize/2, -tSize/2, tSize, tSize);
    if (type === 'toxic') {
        // blue metallic turret for toxic tank
        ctx.fillStyle = '#2ecc71';
        ctx.fillRect(-tSize/2, -tSize/2, tSize, tSize);
        // simple shine
        ctx.fillStyle = 'rgba(255,255,255,0.12)';
        ctx.fillRect(-tSize/2 + 2, -tSize/2 + 2, tSize - 4, tSize/3);
    }
    if (type === 'buratino') {
    }
    if (type === 'ice') {
        // ice crystals on turret
        ctx.fillStyle = 'rgba(255,255,255,0.9)';
        // crystal on turret top-left
        ctx.beginPath();
        ctx.moveTo(-tSize/2 + 2, -tSize/2 + 2);
        ctx.lineTo(-tSize/2 + 5, -tSize/2 - 3);
        ctx.lineTo(-tSize/2 + 8, -tSize/2 + 2);
        ctx.closePath();
        ctx.fill();
        // crystal on turret bottom-right
        ctx.beginPath();
        ctx.moveTo(tSize/2 - 8, tSize/2 - 2);
        ctx.lineTo(tSize/2 - 5, tSize/2 + 3);
        ctx.lineTo(tSize/2 - 2, tSize/2 - 2);
        ctx.closePath();
        ctx.fill();
    } else if (type === 'buratino') {
        // textured purple turret to better match the in-game Buratino appearance
        // base gradient
        const grad = ctx.createLinearGradient(-tSize/2, -tSize/2, tSize/2, tSize/2);
        grad.addColorStop(0, '#B58CEB');
        grad.addColorStop(0.5, '#8F63D6');
        grad.addColorStop(1, '#6E38B0');
        ctx.fillStyle = grad;
        ctx.fillRect(-tSize/2, -tSize/2, tSize, tSize);

        // subtle vertical sheen stripes
        ctx.fillStyle = 'rgba(255,255,255,0.04)';
        const stripeW = Math.max(3, Math.floor(tSize / 12));
        for (let s = -tSize/2; s < tSize/2; s += stripeW * 3) {
            ctx.fillRect(s, -tSize/2, stripeW, tSize);
        }

        // panel seams
        ctx.strokeStyle = 'rgba(0,0,0,0.18)'; ctx.lineWidth = 1;
        ctx.beginPath(); ctx.moveTo(-tSize/2 + 6, -tSize/4); ctx.lineTo(tSize/2 - 6, -tSize/4); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(-tSize/2 + 6, tSize/4); ctx.lineTo(tSize/2 - 6, tSize/4); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(-tSize/8, -tSize/2 + 6); ctx.lineTo(-tSize/8, tSize/2 - 6); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(tSize/8, -tSize/2 + 6); ctx.lineTo(tSize/8, tSize/2 - 6); ctx.stroke();

        // rivets (small dark dots)
        ctx.fillStyle = 'rgba(0,0,0,0.22)';
        const rivetGap = Math.max(12, Math.floor(tSize / 6));
        for (let rx = -tSize/2 + 8; rx <= tSize/2 - 8; rx += rivetGap) {
            for (let ry = -tSize/2 + 8; ry <= tSize/2 - 8; ry += rivetGap) {
                ctx.beginPath(); ctx.arc(rx, ry, 1.3, 0, Math.PI * 2); ctx.fill();
            }
        }

        // horizontal rocket tubes across the turret (rows x cols)
        ctx.fillStyle = '#222';
        const rows = 3;
        const cols = Math.max(5, Math.floor(tSize / 8));
        const tubeH = Math.max(4, Math.floor(tSize / (rows * 3)));
        const inset = 6;
        const usableW = tSize - inset * 2;
        const usableH = tSize - inset * 2;

        for (let r = 0; r < rows; r++) {
            const ry = -tSize/2 + inset + r * (usableH / (rows - 1 || 1));
            for (let c = 0; c < cols; c++) {
                const cx = -tSize/2 + inset + c * (usableW / (cols - 1 || 1));
                const tw = Math.min(usableW / cols * 0.9, tSize * 0.18);
                // tube base
                ctx.fillStyle = '#222';
                ctx.fillRect(cx - tw/2, ry - tubeH/2, tw, tubeH);
                // tube highlight
                ctx.fillStyle = 'rgba(255,255,255,0.08)';
                ctx.fillRect(cx - tw/2 + 1, ry - tubeH/2 + 1, tw - 2, Math.max(1, tubeH - 2));
                // small inner darkness to suggest depth
                ctx.fillStyle = 'rgba(0,0,0,0.35)';
                ctx.fillRect(cx + tw/4, ry - tubeH/4, tw/2, tubeH/2);
            }
        }
    }
    // barrel
    if (type !== 'buratino') {
        ctx.fillStyle = type === 'ice' ? '#B0C4DE' : type === 'fire' ? '#FFA500' : '#111';
        const barrelLen = Math.max(20, W * 0.45) * turretScale * (type === 'normal' && turretScale === 1 ? 1.65 : 1);
        const barrelH = Math.max(4, H * 0.08) * turretScale * (type === 'normal' && turretScale === 1 ? 1.75 : 1);
        if (type === 'fire') {
            // special flamethrower nozzle
            ctx.beginPath();
            ctx.moveTo(tSize/2, 0);
            ctx.lineTo(tSize/2 + barrelLen, -barrelH);
            ctx.lineTo(tSize/2 + barrelLen, barrelH);
            ctx.closePath();
            ctx.fill();
        } else {
            ctx.fillRect(tSize/2 - 2 * turretScale, -barrelH/2, barrelLen, barrelH);
        }
    }
    ctx.restore();
}
function drawPreview() {
    if (!previewCtx) return;
    previewCtx.clearRect(0,0,previewCanvas.width, previewCanvas.height);
    // draw tank smaller and square (half size) with larger turret/barrel for preview
    const side = Math.min(previewCanvas.width, previewCanvas.height) / 2; // –ø–æ–ª–æ–≤–∏–Ω–∞ –º–µ–Ω—å—à–µ–π —Å—Ç–æ—Ä–æ–Ω—ã
    drawTankOn(previewCtx, previewCanvas.width/2, previewCanvas.height/2, side, side, tank.color, tank.turretAngle, 1, tankType);
}
function drawCharacterPreviews() {
    if (normalTankCtx) {
        normalTankCtx.clearRect(0,0,normalTankPreview.width, normalTankPreview.height);
        const side = Math.min(normalTankPreview.width, normalTankPreview.height) / 2;
        drawTankOn(normalTankCtx, normalTankPreview.width/2, normalTankPreview.height/2, side, side, '#0000FF', 0, 1, 'normal');
    }
    if (iceTankCtx) {
        iceTankCtx.clearRect(0,0,iceTankPreview.width, iceTankPreview.height);
        const side = Math.min(iceTankPreview.width, iceTankPreview.height) / 2;
        drawTankOn(iceTankCtx, iceTankPreview.width/2, iceTankPreview.height/2, side, side, '#0000FF', 0, 1, 'ice');
    }
    if (fireTankCtx) {
        fireTankCtx.clearRect(0,0,fireTankPreview.width, fireTankPreview.height);
        const side = Math.min(fireTankPreview.width, fireTankPreview.height) / 2;
        drawTankOn(fireTankCtx, fireTankPreview.width/2, fireTankPreview.height/2, side, side, '#0000FF', 0, 1, 'fire');
    }
    if (buratinoTankCtx) {
        buratinoTankCtx.clearRect(0,0,buratinoTankPreview.width, buratinoTankPreview.height);
        const side = Math.min(buratinoTankPreview.width, buratinoTankPreview.height) / 2;
        drawTankOn(buratinoTankCtx, buratinoTankPreview.width/2, buratinoTankPreview.height/2, side, side, '#0000FF', 0, 1, 'buratino');
    }
    if (toxicTankCtx) {
        toxicTankCtx.clearRect(0,0,toxicTankPreview.width, toxicTankPreview.height);
        const side = Math.min(toxicTankPreview.width, toxicTankPreview.height) / 2;
        drawTankOn(toxicTankCtx, toxicTankPreview.width/2, toxicTankPreview.height/2, side, side, '#0000FF', 0, 1, 'toxic');
    }
}

// Start button handler (open mode selection modal)
const mainMenu = document.getElementById('mainMenu');
const modeModal = document.getElementById('modeModal');
const startBtn = document.getElementById('startBtn');
if (startBtn) startBtn.addEventListener('click', () => {
    if (modeModal) modeModal.style.display = 'flex';
});

// Mode buttons
const modeSingle = document.getElementById('modeSingle');
const modeTeam = document.getElementById('modeTeam');
const modeCancel = document.getElementById('modeCancel');

function startGame(mode) {
    // reset basic state
    tank.turretAngle = 0; tank.hp = 3; tank.artilleryMode = false; tank.artilleryTimer = 0; enemies = []; bullets = []; particles = [];
    navNeedsRebuild = true;

    if (mode === 'single') {
        // normal world
        worldWidth = 900; worldHeight = 700;
        canvas.width = DISPLAY_W; canvas.height = DISPLAY_H;
        tank.x = 50; tank.y = 50;
        generateMap();
    } else if (mode === 'team') {
        // larger world map
        worldWidth = 1400; worldHeight = 1000;
        canvas.width = DISPLAY_W; canvas.height = DISPLAY_H;
        tank.x = 60; tank.y = 60;
        generateMap();
        spawnTeamMode();
        cameraFollow = true;
    } else if (mode === 'war') {
        // large world (previously 6x) ‚Äî reduced by half to 3x for performance
        worldWidth = 900 * 3; worldHeight = 700 * 3;
        canvas.width = DISPLAY_W; canvas.height = DISPLAY_H;
        // place player and spawn war layout
        tank.x = 120; tank.y = 120; tank.team = 0; tank.hp = 3; tank.alive = true; tank.respawnTimer = 0; tank.respawnCount = 0;
        // coarser nav grid for performance
        navCell = 48;
        generateMap();
        spawnWarMode();
        cameraFollow = true;
    }

    // set current mode for runtime logic
    currentMode = mode;

    if (modeModal) modeModal.style.display = 'none';
    if (mainMenu) mainMenu.style.display = 'none';
    gameState = 'playing';
    navNeedsRebuild = true;
    try { if (typeof draw === 'function') draw(); } catch (e) { /* ignore */ }
}

                // very large world (6x single)
                worldWidth = 900 * 6; worldHeight = 700 * 6;
                // keep display canvas small for performance
                canvas.width = DISPLAY_W; canvas.height = DISPLAY_H;
if (modeTeam) modeTeam.addEventListener('click', () => startGame('team'));
if (modeSingle) modeSingle.addEventListener('click', () => startGame('single'));
// War mode button (added dynamically to modal) ‚Äî insert above Cancel for consistent spacing
const modeWarBtn = document.createElement('button');
modeWarBtn.id = 'modeWar';
modeWarBtn.textContent = '–í–æ–π–Ω–∞ (2x10)';
modeWarBtn.style.padding = '10px 18px';
modeWarBtn.style.width = '80%';
modeWarBtn.style.fontSize = '16px';
if (modeModal) {
    // find the inner button group (the second div inside the modal container)
    const container = modeModal.querySelector('div');
    const btnGroup = container ? container.querySelector('div') : null;
    if (btnGroup) {
        // insert the War button before the Cancel button so it appears above
        const cancelBtn = btnGroup.querySelector('#modeCancel');
        if (cancelBtn) btnGroup.insertBefore(modeWarBtn, cancelBtn);
        else btnGroup.appendChild(modeWarBtn);
    } else {
        container.appendChild(modeWarBtn);
    }
}
if (modeWarBtn) modeWarBtn.addEventListener('click', () => startGame('war'));
if (modeCancel) modeCancel.addEventListener('click', () => { if (modeModal) modeModal.style.display = 'none'; });

// Shop button handler
const shopModal = document.getElementById('shopModal');
const characterModal = document.getElementById('characterModal');
const shopBtn = document.getElementById('shopBtn');
const characterBtn = document.getElementById('characterBtn');
const buyContainer = document.getElementById('buyContainer');
const buySuperContainer = document.getElementById('buySuperContainer');
const shopCancel = document.getElementById('shopCancel');
const characterCancel = document.getElementById('characterCancel');
if (shopBtn) shopBtn.addEventListener('click', () => { if (shopModal) shopModal.style.display = 'flex'; });
if (characterBtn) characterBtn.addEventListener('click', () => { if (characterModal) { characterModal.style.display = 'flex'; drawCharacterPreviews(); } });
if (shopCancel) shopCancel.addEventListener('click', () => { if (shopModal) shopModal.style.display = 'none'; });
if (characterCancel) characterCancel.addEventListener('click', () => { if (characterModal) characterModal.style.display = 'none'; });
if (buyContainer) buyContainer.addEventListener('click', () => {
    if (coins >= 100) {
        coins -= 100;
        openContainer();
        updateCoinDisplay();
    } else {
        alert('–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –º–æ–Ω–µ—Ç!');
    }
});
if (buySuperContainer) buySuperContainer.addEventListener('click', () => {
    if (coins >= 200) {
        coins -= 200;
        openSuperContainer();
        updateCoinDisplay();
    } else {
        alert('–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –º–æ–Ω–µ—Ç!');
    }
});

const selectNormalTank = document.getElementById('selectNormalTank');
const selectIceTank = document.getElementById('selectIceTank');
const selectFireTank = document.getElementById('selectFireTank');
const selectBuratinoTank = document.getElementById('selectBuratinoTank');
const selectToxicTank = document.getElementById('selectToxicTank');
if (selectNormalTank) selectNormalTank.addEventListener('click', () => {
    tankType = 'normal';
    tankColor = '#0000FF';
    tank.color = tankColor;
    if (characterModal) characterModal.style.display = 'none';
});
if (selectIceTank) selectIceTank.addEventListener('click', () => {
    tankType = 'ice';
    tankColor = '#0000FF';
    tank.color = tankColor;
    if (characterModal) characterModal.style.display = 'none';
});
if (selectFireTank) selectFireTank.addEventListener('click', () => {
    tankType = 'fire';
    tankColor = '#0000FF';
    tank.color = tankColor;
    if (characterModal) characterModal.style.display = 'none';
});
if (selectBuratinoTank) selectBuratinoTank.addEventListener('click', () => {
    tankType = 'buratino';
    tankColor = '#0000FF';
    tank.color = tankColor;
    if (characterModal) characterModal.style.display = 'none';
});
if (selectToxicTank) selectToxicTank.addEventListener('click', () => {
    tankType = 'toxic';
    tankColor = '#0000FF';
    tank.color = tankColor;
    tank.megaGasUsed = false;
    if (characterModal) characterModal.style.display = 'none';
});

// –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é
if (mainMenu) mainMenu.style.display = 'flex';

// –û–±–Ω–æ–≤–ª—è—Ç—å –ø—Ä–µ–≤—å—é —Ç–∞–Ω–∫–∞ –≤ –º–µ–Ω—é –≤ —Ü–∏–∫–ª–µ, —á—Ç–æ–±—ã –æ–Ω–æ –≤—Å–µ–≥–¥–∞ —Ä–∏—Å–æ–≤–∞–ª–æ—Å—å
function previewLoop() {
    if (previewCtx) drawPreview();
    requestAnimationFrame(previewLoop);
}
requestAnimationFrame(previewLoop);

/**
 * –ì–ï–ù–ï–†–ê–¶–ò–Ø –ö–ê–†–¢–´
 * –°–æ–∑–¥–∞–µ–º –¥–ª–∏–Ω–Ω—ã–µ —Å—Ç–µ–Ω—ã –∫–∞–∫ –≤ –æ—Ä–∏–≥–∏–Ω–∞–ª–µ (–≤–µ—Ä—Ç–∏–∫–∞–ª—å–Ω—ã–µ –∏ –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω—ã–µ)
 */
function generateMap() {
    objects = [];
    const step = 100; // –®–∞–≥ —Å–µ—Ç–∫–∏
    
    // –í–Ω–µ—à–Ω–∏–µ –≥—Ä–∞–Ω–∏—Ü—ã (–Ω–µ–≤–∏–¥–∏–º—ã–µ, —á—Ç–æ–±—ã –Ω–µ –≤—ã–µ–∑–∂–∞—Ç—å)
    // –í–Ω—É—Ç—Ä–µ–Ω–Ω–∏–µ —Å—Ç–µ–Ω—ã
    for (let x = step; x < worldWidth - step; x += step) {
        for (let y = step; y < worldHeight - step; y += step) {
            
            if (Math.random() > 0.65) {
                const isVertical = Math.random() > 0.5;
                const length = Math.floor(Math.random() * 2) + 1; // –î–ª–∏–Ω–∞ 1-2 –±–ª–æ–∫–∞
                
                if (isVertical) {
                    objects.push({
                        x: x + 25, y: y, 
                        w: 30, h: length * step - 20, 
                        type: 'wall', color: '#2b2b2b'
                    });
                } else {
                    objects.push({
                        x: x, y: y + 25, 
                        w: length * step - 20, h: 30, 
                        type: 'wall', color: '#2b2b2b'
                    });
                }
            }
        }
    }
    
    // –Ø—â–∏–∫–∏ –≤ —Å–ª—É—á–∞–π–Ω—ã—Ö –º–µ—Å—Ç–∞—Ö, –ø—Ä–æ–≤–µ—Ä—è—è –∫–æ–ª–ª–∏–∑–∏–∏ —Å–æ —Å—Ç–µ–Ω–∞–º–∏
    for (let x = step; x < worldWidth - step; x += step) {
        for (let y = step; y < worldHeight - step; y += step) {
            if (Math.random() > 0.8) {
                const newBox = {
                    x: x + 25, y: y + 25, 
                    w: 50, h: 50, 
                    type: 'box', color: '#7a4a21'
                };
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ –ø–µ—Ä–µ—Å–µ–∫–∞–µ—Ç—Å—è –ª–∏ —Å —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–º–∏ —Å—Ç–µ–Ω–∞–º–∏
                let canPlace = true;
                for (let obj of objects) {
                    if (obj.type === 'wall' && checkRectCollision(newBox, obj)) {
                        canPlace = false;
                        break;
                    }
                }
                if (canPlace) {
                    objects.push(newBox);
                }
            }
        }
    }
    
    // –£–¥–∞–ª—è–µ–º –æ–±—ä–µ–∫—Ç—ã, –∫–æ—Ç–æ—Ä—ã–µ —Å–ª–∏—à–∫–æ–º –±–ª–∏–∑–∫–æ –∫ —Å—Ç–∞—Ä—Ç—É –∏–≥—Ä–æ–∫–∞
    objects = objects.filter(obj => {
        const dist = Math.hypot(obj.x - tank.x, obj.y - tank.y);
        return dist > 100;
    });

    // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –≤—Ä–∞–≥–æ–≤ –≤ —É–≥–ª–∞—Ö
    enemies = [];
    const cornerPositions = [
        {x: worldWidth - 50, y: 50},
        {x: 50, y: worldHeight - 50},
        {x: worldWidth - 50, y: worldHeight - 50}
    ];
    for (let i = 0; i < 3; i++) {
        const cp = cornerPositions[i];
        const p = findFreeSpot(cp.x - 19, cp.y - 19, 38, 38);
        enemies.push({
            x: p.x, y: p.y, w: 38, h: 38,
            color: ['#8B0000', '#006400', '#FFD700'][i],
            hp: 3,
            turretAngle: 0,
            baseAngle: 0,
            speed: 2.5,
            trackOffset: 0,
            alive: true,
            stuckCount: 0,
            fireCooldown: 0,
            team: i+1,
            dodgeAccuracy: 0.75 + Math.random() * 0.2,
            paralyzed: false,
            paralyzedTime: 0
        });
    }
}

// Spawn teams: numTeams teams, each of teamSize tanks
function spawnAllies(numTeams, teamSize) {
    allies = [];
    const pads = [50, 50];
    const corners = [
        { x: 60, y: 60 },
        { x: worldWidth - 60, y: 60 },
        { x: 60, y: worldHeight - 60 },
        { x: worldWidth - 60, y: worldHeight - 60 }
    ];
    for (let t = 0; t < numTeams; t++) {
        const teamColor = ['#8B0000', '#006400', '#FFD700', '#00BFFF'][t % 4];
        const base = corners[t % corners.length];
        for (let s = 0; s < teamSize; s++) {
            const offset = s * 44;
            // ensure ally spawn is inside and not colliding
            let pos = findFreeSpot(base.x + offset, base.y + offset, 38, 38);
            allies.push({
                x: pos.x, y: pos.y, w: 38, h: 38,
                color: teamColor,
                hp: 100,
                turretAngle: 0,
                baseAngle: 0,
                speed: 2.5,
                trackOffset: 0,
                alive: true,
                team: t,
                fireCooldown: 0,
                stuckCount: 0,
                dodgeAccuracy: 0.75 + Math.random() * 0.2,
                paralyzed: false,
                paralyzedTime: 0
            });
        }
    }
    navNeedsRebuild = true;
}

// Spawn team-mode: place player + 1 ally in one corner, spawn 6 enemies in other corners (total 8 players)
function spawnTeamMode() {
    enemies = [];
    allies = [];
    const corners = [
        { x: 60, y: 60 },
        { x: worldWidth - 60, y: 60 },
        { x: 60, y: worldHeight - 60 },
        { x: worldWidth - 60, y: worldHeight - 60 }
    ];

    // helper: remove objects overlapping a rectangle so spawn areas are free
    function clearArea(x, y, w, h) {
        objects = objects.filter(o => {
            const ox = o.x, oy = o.y, ow = o.w || 40, oh = o.h || 40;
            if (ox < x + w && ox + ow > x && oy < y + h && oy + oh > y) return false;
            return true;
        });
    }

    // choose corner 0 for player team
    const playerCorner = corners[0];
    tank.x = playerCorner.x; tank.y = playerCorner.y; tank.team = 0;
    // clear around player spawn
    clearArea(playerCorner.x - 48, playerCorner.y - 48, 96, 96);
    // spawn one ally near player (use player's color)
            allies.push({ x: playerCorner.x + 44, y: playerCorner.y + 10, w: 38, h: 38, color: tank.color, hp: 3, turretAngle:0, baseAngle:0, speed:2.5, trackOffset:0, alive:true, team:0, stuckCount:0, fireCooldown:0, dodgeAccuracy: 0.78 + Math.random()*0.15, paralyzed: false, paralyzedTime: 0 });

    const enemyColors = ['#006400', '#FFD700', '#00BFFF'];
    // spawn other corners with 2 enemies each; clear spawn areas first
    for (let ci = 1; ci < 4; ci++) {
        const base = corners[ci];
        clearArea(base.x - 48, base.y - 48, 96, 96);
        for (let k = 0; k < 2; k++) {
            enemies.push({ x: base.x + k*44, y: base.y + k*28, w:38, h:38, color: enemyColors[(ci-1)%enemyColors.length], hp:3, turretAngle:0, baseAngle:0, speed:2.5, trackOffset:0, alive:true, team:ci, stuckCount:0, fireCooldown:0, dodgeAccuracy: 0.7 + Math.random()*0.25, paralyzed: false, paralyzedTime: 0 });
        }
    }

    // add explosive barrels for team mode only (place a few in free spots)
    const barrelCount = 5;
    for (let b = 0; b < barrelCount; b++) {
        // try random positions near center area
        const rx = 80 + Math.random() * (worldWidth - 160);
        const ry = 80 + Math.random() * (worldHeight - 160);
        const p = findFreeSpot(rx - 20, ry - 20, 40, 40, 300, 16);
        // avoid placing extremely close to player
        if (Math.hypot(p.x - tank.x, p.y - tank.y) < 120) continue;
        objects.push({ x: p.x, y: p.y, w: 40, h: 40, type: 'barrel', color: '#b33' });
    }

    navNeedsRebuild = true;
}

// Spawn War mode: 2 teams x 10 players (player is on blue team = team 0)
function spawnWarMode() {
    enemies = [];
    allies = [];
    objects = objects || [];
    // huge map already set in startGame
    const corners = [
        { x: 120, y: 120 },
        { x: worldWidth - 120, y: worldHeight - 120 }
    ];
    // record team spawn centers
    const teamSpawns = [ corners[0], corners[1] ];
    warTeamSpawns = teamSpawns;

    // place player near team 0 spawn
    const p0 = findFreeSpot(teamSpawns[0].x - 19, teamSpawns[0].y - 19, tank.w, tank.h, 600, 40);
    tank.x = p0.x; tank.y = p0.y; tank.team = 0; tank.hp = 3; tank.alive = true; tank.respawnTimer = 0;

    // spawn allies (team 0) - 9 bots + player = 10
    for (let i = 0; i < 9; i++) {
            const rx = teamSpawns[0].x + 30 + (i % 3) * 80 + (Math.random() - 0.5) * 30;
            const ry = teamSpawns[0].y + 30 + Math.floor(i/3) * 80 + (Math.random() - 0.5) * 30;
        const pos = findFreeSpot(rx, ry, 38, 38, 600, 24);
        allies.push({ x: pos.x, y: pos.y, w:38, h:38, color: tank.color || '#00BFFF', hp:3, turretAngle:0, baseAngle:0, speed:2.5, trackOffset:0, alive:true, team:0, fireCooldown:0, stuckCount:0, dodgeAccuracy:0.75 + Math.random()*0.2, respawnCount:0, paralyzed: false, paralyzedTime: 0 });
    }

    // spawn enemies (team 1) - 10 bots
    for (let i = 0; i < 10; i++) {
        const rx = teamSpawns[1].x - 30 - (i % 4) * 80 + (Math.random() - 0.5) * 40;
        const ry = teamSpawns[1].y - 30 - Math.floor(i/4) * 80 + (Math.random() - 0.5) * 40;
        const pos = findFreeSpot(rx, ry, 38, 38, 600, 24);
        enemies.push({ x: pos.x, y: pos.y, w:38, h:38, color:'#B22222', hp:3, turretAngle:0, baseAngle:0, speed:2.5, trackOffset:0, alive:true, team:1, fireCooldown:0, stuckCount:0, dodgeAccuracy:0.7 + Math.random()*0.2, respawnCount:0, paralyzed: false, paralyzedTime: 0 });
    }

    // spawn some barrels and boxes in war map
    for (let b = 0; b < 20; b++) {
        const rx = 200 + Math.random() * (worldWidth - 400);
        const ry = 200 + Math.random() * (worldHeight - 400);
        const p = findFreeSpot(rx - 20, ry - 20, 40, 40, 800, 32);
        objects.push({ x: p.x, y: p.y, w: 40, h: 40, type: Math.random() > 0.85 ? 'barrel' : 'box', color: '#7a4a21' });
    }

    navNeedsRebuild = true;
}

function teamHasAliveMember(team) {
    if (team === 0) {
        if (tank.alive) return true;
        for (const a of allies) if (a && a.alive) return true;
        return false;
    } else {
        for (const e of enemies) if (e && e.alive) return true;
        return false;
    }
}

/**
 * –§–ò–ó–ò–ö–ê –ò –ö–û–õ–õ–ò–ó–ò–ò
 */
function checkRectCollision(r1, r2) {
    return r1.x < r2.x + r2.w && r1.x + r1.w > r2.x &&
           r1.y < r2.y + r2.h && r1.y + r1.h > r2.y;
}

// –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, —á–∏—Å—Ç –ª–∏ –ø—É—Ç—å –≤–¥–æ–ª—å –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è `angle` –Ω–∞ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ `dist`.
// –î–µ–ª–∞–µ—Ç –Ω–µ—Å–∫–æ–ª—å–∫–æ —Å—ç–º–ø–ª–æ–≤ –ø–æ –ø—É—Ç–∏, —á—Ç–æ–±—ã –∑–∞–º–µ—Ç–∏—Ç—å —É–∑–∫–∏–µ –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏—è.
function pathClearFor(entity, angle, dist, samples = 4) {
    // use entity center for sampling so narrow passages are tested correctly
    const cx = entity.x + (entity.w || 0) / 2;
    const cy = entity.y + (entity.h || 0) / 2;
    for (let s = 1; s <= samples; s++) {
        const t = s / samples;
        const sampleCx = cx + Math.cos(angle) * dist * t;
        const sampleCy = cy + Math.sin(angle) * dist * t;
        const tx = sampleCx - (entity.w || 0) / 2;
        const ty = sampleCy - (entity.h || 0) / 2;
        const rect = { x: tx, y: ty, w: entity.w, h: entity.h };
        for (const obj of objects) {
            if (checkRectCollision(rect, obj)) return false;
        }
    }
    // —Ç–∞–∫–∂–µ –ø—Ä–æ–≤–µ—Ä–∫–∞ –≥—Ä–∞–Ω–∏—Ü –∫–∞–Ω–≤—ã –ø–æ –∫–æ–Ω–µ—á–Ω–æ–π –ø–æ–∑–∏—Ü–∏–∏ —Ü–µ–Ω—Ç—Ä–∞
    const endCx = cx + Math.cos(angle) * dist;
    const endCy = cy + Math.sin(angle) * dist;
    const endX = endCx - (entity.w || 0) / 2;
    const endY = endCy - (entity.h || 0) / 2;
    if (endX < 0 || endY < 0 || endX + entity.w > worldWidth || endY + entity.h > worldHeight) return false;
    return true;
}

// –ù–∞–π—Ç–∏ —Å–≤–æ–±–æ–¥–Ω—É—é —Ç–æ—á–∫—É —Ä—è–¥–æ–º —Å (x,y) —á—Ç–æ–±—ã —Å—É—â–Ω–æ—Å—Ç—å –Ω–µ –ø–æ—è–≤–ª—è–ª–∞—Å—å –≤ —Å—Ç–µ–Ω–µ
function findFreeSpot(x, y, w, h, maxRadius = 200, step = 16) {
    // clamp initial
    x = Math.max(0, Math.min(worldWidth - w, x));
    y = Math.max(0, Math.min(canvas.height - h, y));
    // quick check
    function collides(px, py) {
        const rect = { x: px, y: py, w: w, h: h };
        for (const o of objects) if (checkRectCollision(rect, o)) return true;
        return false;
    }
    if (!collides(x, y)) return { x, y };
    // search in expanding square/spiral
    for (let r = step; r <= maxRadius; r += step) {
        for (let dx = -r; dx <= r; dx += step) {
            for (let dy of [-r, r]) {
                const nx = Math.max(0, Math.min(worldWidth - w, x + dx));
                const ny = Math.max(0, Math.min(worldHeight - h, y + dy));
                if (!collides(nx, ny)) return { x: nx, y: ny };
            }
        }
        for (let dy = -r + step; dy <= r - step; dy += step) {
            for (let dx of [-r, r]) {
                const nx = Math.max(0, Math.min(worldWidth - w, x + dx));
                const ny = Math.max(0, Math.min(worldHeight - h, y + dy));
                if (!collides(nx, ny)) return { x: nx, y: ny };
            }
        }
    }
    // fallback clamp
    return { x: Math.max(0, Math.min(worldWidth - w, x)), y: Math.max(0, Math.min(worldHeight - h, y)) };
}

// –ü—Ä–æ–≤–µ—Ä—è–µ–º, –ª–µ—Ç—è—Ç –ª–∏ –ø–æ —Å—É—â–Ω–æ—Å—Ç–∏ —Å–Ω–∞—Ä—è–¥—ã; –µ—Å–ª–∏ –¥–∞ ‚Äî –ø–æ–ø—Ä–æ–±—É–µ–º —É–∫–ª–æ–Ω–∏—Ç—å—Å—è
function tryDodgeIncoming(entity) {
    const ex = entity.x + (entity.w||0)/2; const ey = entity.y + (entity.h||0)/2;
    const dangerLookahead = 30; // ticks to look ahead
    const accuracy = (entity.dodgeAccuracy !== undefined) ? entity.dodgeAccuracy : DODGE_BASE_ACCURACY;
    for (const b of bullets) {
        if (!b || b.team === undefined) continue;
        if (b.team === entity.team) continue; // ignore friendly
        // probabilistic: sometimes AI fails to notice or react
        if (Math.random() > accuracy) continue;
        const bvx = b.vx, bvy = b.vy;
        const rx = ex - b.x, ry = ey - b.y;
        const vv = bvx*bvx + bvy*bvy;
        if (vv === 0) continue;
        const t = (rx*bvx + ry*bvy) / vv; // time to closest approach in ticks (approx)
        if (t < 0 || t > dangerLookahead) continue;
        const cx = b.x + bvx * t, cy = b.y + bvy * t;
        const dist = Math.hypot(cx - ex, cy - ey);
        const safeDist = Math.max((entity.w||20), (entity.h||20)) * 0.9;
        if (dist < safeDist) {
            // try perpendicular dodge but add angle noise proportional to (1-accuracy)
            const bulletAng = Math.atan2(bvy, bvx);
            const maxNoise = Math.PI * 0.45; // up to ~81 degrees
            const noise = (1 - accuracy) * maxNoise * (Math.random() - 0.5) * 2;
            const cand = [bulletAng + Math.PI/2 + noise, bulletAng - Math.PI/2 + noise, Math.atan2(ey - b.y, ex - b.x) + noise];
            for (const ang of cand) {
                if (moveSmallSteps(entity, ang, (entity.speed || 2.5) * 1.3)) {
                    entity.baseAngle = ang;
                    return true;
                }
            }
            // if couldn't move, try small backward step (with chance to fail as well)
            const backAng = Math.atan2(ey - b.y, ex - b.x) + ((1 - accuracy) * (Math.random() - 0.5));
            if (moveSmallSteps(entity, backAng, (entity.speed || 2.5) * 0.9)) {
                entity.baseAngle = backAng;
                return true;
            }
        }
    }
    return false;
}

// –í–∑—Ä—ã–≤ –±–æ—á–∫–∏: —ç—Ñ—Ñ–µ–∫—Ç—ã –∏ —É—Ä–æ–Ω –≤—Å–µ–º —Ç–∞–Ω–∫–∞–º –≤ —Ä–∞–¥–∏—É—Å–µ
function explodeBarrel(obj) {
    // visual particles
    for (let i = 0; i < 40; i++) {
        const ang = Math.random() * Math.PI * 2;
        const sp = Math.random() * 6 + 2;
        particles.push({ x: obj.x + obj.w/2, y: obj.y + obj.h/2, vx: Math.cos(ang) * sp, vy: Math.sin(ang) * sp, life: 1, size: 2 + Math.random() * 3 });
    }
    // explosion damage radius
    const R = 120;
    function applyDamageToTank(t) {
        if (!t) return;
        const tx = t.x + (t.w||0)/2, ty = t.y + (t.h||0)/2;
        const dist = Math.hypot(tx - (obj.x + obj.w/2), ty - (obj.y + obj.h/2));
        if (dist <= R) {
            const damage = Math.max(1, Math.round((1 - dist / R) * 3));
            t.hp = (t.hp || 0) - damage;
            if (t === tank && t.hp <= 0) {
                for (let k = 0; k < 30; k++) spawnParticle(t.x + t.w/2, t.y + t.h/2);
                if (currentMode === 'war') { t.alive = false; t.respawnTimer = 600; }
                else { gameState = 'lose'; }
            }
        }
    }
    // apply to player
    applyDamageToTank(tank);
    // allies
    for (let i = allies.length - 1; i >= 0; i--) {
        const a = allies[i]; applyDamageToTank(a);
        if (a.hp <= 0) {
            if (currentMode === 'war') { a.alive = false; a.respawnTimer = 600; for (let k = 0; k < 8; k++) spawnParticle(a.x + a.w/2, a.y + a.h/2); }
            else { allies.splice(i, 1); for (let k = 0; k < 8; k++) spawnParticle(a.x + a.w/2, a.y + a.h/2); }
        }
    }
    // enemies
    for (let i = enemies.length - 1; i >= 0; i--) {
        const e = enemies[i]; applyDamageToTank(e);
        if (e.hp <= 0) {
            if (currentMode === 'war') { e.alive = false; e.respawnTimer = 600; for (let k = 0; k < 10; k++) spawnParticle(e.x + e.w/2, e.y + e.h/2); }
            else { enemies.splice(i, 1); for (let k = 0; k < 10; k++) spawnParticle(e.x + e.w/2, e.y + e.h/2); }
        }
    }
    // remove barrel object
    const idx = objects.indexOf(obj);
    if (idx >= 0) objects.splice(idx, 1);
    navNeedsRebuild = true;
}

// –í–∑—Ä—ã–≤ —Ä–∞–∫–µ—Ç—ã: —ç—Ñ—Ñ–µ–∫—Ç—ã –∏ —É—Ä–æ–Ω –≤—Å–µ–º —Ç–∞–Ω–∫–∞–º –≤ —Ä–∞–¥–∏—É—Å–µ
function explodeRocket(bullet) {
    // visual explosion circle
    objects.push({
        type: 'explosion',
        x: bullet.x,
        y: bullet.y,
        radius: 80,
        life: 30,
        color: '#FFA500'
    });
    // explosion damage radius
    const R = 80;
    function applyDamageToTank(t) {
        if (!t) return;
        const tx = t.x + (t.w||0)/2, ty = t.y + (t.h||0)/2;
        const dist = Math.hypot(tx - bullet.x, ty - bullet.y);
        if (dist <= R) {
            const damage = Math.max(1, Math.round((1 - dist / R) * 2));
            t.hp = (t.hp || 0) - damage;
            if (t === tank && t.hp <= 0) {
                for (let k = 0; k < 30; k++) spawnParticle(t.x + t.w/2, t.y + t.h/2);
                if (currentMode === 'war') { t.alive = false; t.respawnTimer = 600; }
                else { gameState = 'lose'; }
            }
        }
    }
    // apply to player
    applyDamageToTank(tank);
    // allies
    for (let i = allies.length - 1; i >= 0; i--) {
        const a = allies[i]; applyDamageToTank(a);
        if (a.hp <= 0) {
            if (currentMode === 'war') { a.alive = false; a.respawnTimer = 600; for (let k = 0; k < 8; k++) spawnParticle(a.x + a.w/2, a.y + a.h/2); }
            else { allies.splice(i, 1); for (let k = 0; k < 8; k++) spawnParticle(a.x + a.w/2, a.y + a.h/2); }
        }
    }
    // enemies
    for (let i = enemies.length - 1; i >= 0; i--) {
        const e = enemies[i]; applyDamageToTank(e);
        if (e.hp <= 0) {
            if (currentMode === 'war') { e.alive = false; e.respawnTimer = 600; for (let k = 0; k < 10; k++) spawnParticle(e.x + e.w/2, e.y + e.h/2); }
            else { enemies.splice(i, 1); for (let k = 0; k < 10; k++) spawnParticle(e.x + e.w/2, e.y + e.h/2); }
        }
    }
}

// Spawn gas cloud at (x,y). If mega=true, larger radius and longer duration.
function explodeGas(bullet, mega = false) {
    // small visual explosion
    objects.push({ type: 'explosion', x: bullet.x, y: bullet.y, radius: mega ? 80 : 40, life: 30, color: '#66FF66' });
    // gas cloud
    const durationTicks = (mega ? 10 : 5) * 60; // seconds -> ticks
    const radius = mega ? 180 : 90;
    objects.push({ type: 'gas', x: bullet.x, y: bullet.y, radius: radius, life: durationTicks, maxLife: durationTicks, color: 'rgba(100,220,100,0.25)', owner: bullet.owner, isMega: mega });
}

// Global helper: apply area damage at point (x,y)
function applyDamage(x, y, R = 30, coef = 1) {
    function applyDamageToTank(t) {
        if (!t) return;
        const tx = t.x + (t.w||0)/2, ty = t.y + (t.h||0)/2;
        const dist = Math.hypot(tx - x, ty - y);
        if (dist <= R) {
            const damage = Math.max(1, Math.round((1 - dist / R) * coef));
            t.hp = (t.hp || 0) - damage;
            if (t === tank && t.hp <= 0) {
                for (let k = 0; k < 30; k++) spawnParticle(t.x + t.w/2, t.y + t.h/2);
                if (currentMode === 'war') { t.alive = false; t.respawnTimer = 600; }
                else { gameState = 'lose'; }
            }
        }
    }
    applyDamageToTank(tank);
    for (let i = allies.length - 1; i >= 0; i--) {
        const a = allies[i]; applyDamageToTank(a);
        if (a.hp <= 0) {
            if (currentMode === 'war') { a.alive = false; a.respawnTimer = 600; for (let k = 0; k < 8; k++) spawnParticle(a.x + a.w/2, a.y + a.h/2); }
            else { allies.splice(i, 1); for (let k = 0; k < 8; k++) spawnParticle(a.x + a.w/2, a.y + a.h/2); }
        }
    }
    for (let i = enemies.length - 1; i >= 0; i--) {
        const e = enemies[i]; applyDamageToTank(e);
        if (e.hp <= 0) {
            if (currentMode === 'war') { e.alive = false; e.respawnTimer = 600; for (let k = 0; k < 10; k++) spawnParticle(e.x + e.w/2, e.y + e.h/2); }
            else { enemies.splice(i, 1); for (let k = 0; k < 10; k++) spawnParticle(e.x + e.w/2, e.y + e.h/2); }
        }
    }
}

// Open super container: give rare bonus
function openSuperContainer() {
    const bonuses = [
        () => { tank.hp += 1; alert('–†–µ–¥–∫–∏–π –±–æ–Ω—É—Å: +1 HP!'); },
        () => { tank.speed += 0.5; alert('–†–µ–¥–∫–∏–π –±–æ–Ω—É—Å: +–°–∫–æ—Ä–æ—Å—Ç—å!'); },
        () => { tank.color = '#FFD700'; alert('–†–µ–¥–∫–∏–π –±–æ–Ω—É—Å: –∑–æ–ª–æ—Ç–æ–π —Ü–≤–µ—Ç —Ç–∞–Ω–∫–∞!'); },
        () => { tank.color = '#FF1493'; alert('–†–µ–¥–∫–∏–π –±–æ–Ω—É—Å: —Ä–æ–∑–æ–≤—ã–π —Ü–≤–µ—Ç —Ç–∞–Ω–∫–∞!'); },
        () => { tank.color = '#00FFFF'; alert('–†–µ–¥–∫–∏–π –±–æ–Ω—É—Å: —Ü–∏–∞–Ω–æ–≤—ã–π —Ü–≤–µ—Ç —Ç–∞–Ω–∫–∞!'); }
    ];
    const bonus = bonuses[Math.floor(Math.random() * bonuses.length)];
    bonus();
}

// –ü–æ—Å—Ç—Ä–æ–∏—Ç—å –Ω–∞–≤–∏–≥–∞—Ü–∏–æ–Ω–Ω—É—é —Å–µ—Ç–∫—É: 1 = –±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω–æ, 0 = —Å–≤–æ–±–æ–¥–Ω–æ
function buildNavGrid(cellSize = navCell) {
    navCell = cellSize;
    navCols = Math.ceil(worldWidth / navCell);
    navRows = Math.ceil(worldHeight / navCell);
    navGrid = new Array(navCols * navRows).fill(0);
    for (let j = 0; j < navRows; j++) {
        for (let i = 0; i < navCols; i++) {
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –º–æ–∂–Ω–æ –ª–∏ –ø–æ–º–µ—Å—Ç–∏—Ç—å –∞–≥–µ–Ω—Ç–∞ (—Ç–∞–Ω–∫) —Å —Ü–µ–Ω—Ç—Ä–æ–º –≤ —Ü–µ–Ω—Ç—Ä–µ –∫–ª–µ—Ç–∫–∏
            const center = cellCenter(i, j);
            const agentRect = { x: center.x - navAgentW/2, y: center.y - navAgentH/2, w: navAgentW, h: navAgentH };
            let blocked = false;
            for (const o of objects) {
                if (o.type === 'wall') {
                    if (checkRectCollision(agentRect, o)) { blocked = true; break; }
                }
                // –î–ª—è —è—â–∏–∫–æ–≤ —Å—á–∏—Ç–∞–µ–º –∫–ª–µ—Ç–∫—É –±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω–Ω–æ–π, –µ—Å–ª–∏ —è—â–∏–∫ –∑–∞–Ω–∏–º–∞–µ—Ç –∑–Ω–∞—á–∏—Ç–µ–ª—å–Ω—É—é —á–∞—Å—Ç—å –∫–ª–µ—Ç–∫–∏
                if (o.type === 'box') {
                    if (checkRectCollision(agentRect, o)) { blocked = true; break; }
                }
            }
            // –¢–∞–∫–∂–µ —É—á–∏—Ç—ã–≤–∞–µ–º –≥—Ä–∞–Ω–∏—Ü—ã –∫–∞–Ω–≤—ã
            if (agentRect.x < 0 || agentRect.y < 0 || agentRect.x + agentRect.w > worldWidth || agentRect.y + agentRect.h > worldHeight) blocked = true;
            navGrid[j * navCols + i] = blocked ? 1 : 0;
        }
    }
}

function worldToCell(x, y) {
    const ci = Math.max(0, Math.min(navCols - 1, Math.floor(x / navCell)));
    const rj = Math.max(0, Math.min(navRows - 1, Math.floor(y / navCell)));
    return { ci, rj };
}
function cellCenter(i, j) { return { x: (i + 0.5) * navCell, y: (j + 0.5) * navCell }; }

// –ù–∞–π—Ç–∏ –ø—É—Ç—å –æ—Ç –º–∏—Ä–æ–≤—ã—Ö –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç start->goal, –≤–µ—Ä–Ω—É—Ç—å –º–∞—Å—Å–∏–≤ –∫–æ–Ω—Ç—Ä–æ–ª—å–Ω—ã—Ö —Ç–æ—á–µ–∫ (—Ü–µ–Ω—Ç—Ä—ã —è—á–µ–µ–∫)
function findPath(sx, sy, gx, gy) {
    if (!navGrid) buildNavGrid();
    const start = worldToCell(sx, sy);
    const goal = worldToCell(gx, gy);
    const startKey = start.ci + ',' + start.rj;
    const goalKey = goal.ci + ',' + goal.rj;
    if (navGrid[start.rj * navCols + start.ci]) {
        // try to find nearby free start
        let found = false;
        for (let r = 1; r < 4 && !found; r++) {
            for (let dj = -r; dj <= r && !found; dj++) {
                for (let di = -r; di <= r && !found; di++) {
                    const ni = start.ci + di, nj = start.rj + dj;
                    if (ni < 0 || nj < 0 || ni >= navCols || nj >= navRows) continue;
                    if (!navGrid[nj * navCols + ni]) { start.ci = ni; start.rj = nj; found = true; }
                }
            }
        }
        if (!found) return null;
    }
    if (navGrid[goal.rj * navCols + goal.ci]) {
        let found = false;
        for (let r = 1; r < 6 && !found; r++) {
            for (let dj = -r; dj <= r && !found; dj++) {
                for (let di = -r; di <= r && !found; di++) {
                    const ni = goal.ci + di, nj = goal.rj + dj;
                    if (ni < 0 || nj < 0 || ni >= navCols || nj >= navRows) continue;
                    if (!navGrid[nj * navCols + ni]) { goal.ci = ni; goal.rj = nj; found = true; }
                }
            }
        }
        if (!found) return null;
    }

    const key = (i, j) => i + ',' + j;
    const open = new Map();
    const closed = new Set();
    const gScore = {};
    const fScore = {};
    const cameFrom = {};

    function heuristic(i, j) { return Math.hypot(i - goal.ci, j - goal.rj); }

    const startK = key(start.ci, start.rj);
    gScore[startK] = 0;
    fScore[startK] = heuristic(start.ci, start.rj);
    open.set(startK, { i: start.ci, j: start.rj, f: fScore[startK] });

    const neigh = [ [1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1] ];
    const maxIter = navCols * navRows * 4;
    let iter = 0;
    while (open.size && iter++ < maxIter) {
        // get node in open with min f
        let curKey = null, curNode = null;
        for (const [k,v] of open) { if (!curNode || v.f < curNode.f) { curNode = v; curKey = k; } }
        if (!curNode) break;
        open.delete(curKey);
        if (curNode.i === goal.ci && curNode.j === goal.rj) {
            // reconstruct path
            const path = [];
            let ck = curKey;
            while (ck && cameFrom[ck]) {
                const parts = ck.split(',').map(Number);
                path.push(cellCenter(parts[0], parts[1]));
                ck = cameFrom[ck];
            }
            path.push(cellCenter(start.ci, start.rj));
            path.reverse();
            return path;
        }
        closed.add(curKey);

        for (const d of neigh) {
            const ni = curNode.i + d[0], nj = curNode.j + d[1];
            if (ni < 0 || nj < 0 || ni >= navCols || nj >= navRows) continue;
            const nk = key(ni, nj);
            if (closed.has(nk)) continue;
            if (navGrid[nj * navCols + ni]) continue; // blocked
            const tentativeG = (gScore[curKey] || 0) + ((d[0] && d[1]) ? Math.SQRT2 : 1);
            if (open.has(nk) && tentativeG >= (gScore[nk] || Infinity)) continue;
            cameFrom[nk] = curKey;
            gScore[nk] = tentativeG;
            fScore[nk] = tentativeG + heuristic(ni, nj);
            open.set(nk, { i: ni, j: nj, f: fScore[nk] });
        }
    }
    return null;
}

// –ü—Ä–æ–≤–µ—Ä–∏—Ç—å, –º–æ–∂–Ω–æ –ª–∏ –ø–æ–º–µ—Å—Ç–∏—Ç—å `entity` –≤ –ø–æ–∑–∏—Ü–∏—é x,y –±–µ–∑ –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏–π —Å–æ —Å—Ç–µ–Ω–∞–º–∏
function canPlaceAt(entity, nx, ny) {
    const rect = { x: nx, y: ny, w: entity.w, h: entity.h };
    for (const obj of objects) {
        if (obj.type === 'wall' && checkRectCollision(rect, obj)) return false;
    }
    if (rect.x < 0 || rect.y < 0 || rect.x + rect.w > worldWidth || rect.y + rect.h > worldHeight) return false;
    return true;
}

// –ù–∞–π—Ç–∏ –ø–µ—Ä–≤—ã–π –æ–±—ä–µ–∫—Ç, –ø–µ—Ä–µ—Å–µ–∫–∞—é—â–∏–π –ø—Ä—è–º–æ—É–≥–æ–ª—å–Ω–∏–∫ (–∏–ª–∏ null)
function getCollidingObject(rect) {
    for (const obj of objects) {
        if (checkRectCollision(rect, obj)) return obj;
    }
    return null;
}

// –ü–æ–ø—ã—Ç–∞—Ç—å—Å—è —Å–¥–≤–∏–Ω—É—Ç—å entity –Ω–∞ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ dist –≤ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–∏ angle –º–∞–ª—ã–º–∏ —à–∞–≥–∞–º–∏.
// –ï—Å–ª–∏ –Ω–∞ –ø—É—Ç–∏ —è—â–∏–∫ ‚Äî –ø—Ä–µ–¥–ø—Ä–∏–Ω—è—Ç—å –ø–æ–ø—ã—Ç–∫—É –±–µ–∑–æ–ø–∞—Å–Ω–æ –µ–≥–æ —Ç–æ–ª–∫–Ω—É—Ç—å (—Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ —É —è—â–∏–∫–∞ –µ—Å—Ç—å –∫—É–¥–∞ —Å–¥–≤–∏–Ω—É—Ç—å—Å—è).
function moveSmallSteps(entity, angle, dist) {
    const step = 1; // –ø–∏–∫—Å–µ–ª—å–Ω—ã–π —à–∞–≥
    const steps = Math.max(1, Math.round(dist / step));
    const dxStep = Math.cos(angle) * step;
    const dyStep = Math.sin(angle) * step;
    for (let i = 0; i < steps; i++) {
        const nx = entity.x + dxStep;
        const ny = entity.y + dyStep;

        // –ë—ã—Å—Ç—Ä–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ —Å—Ç–µ–Ω—ã/–≥—Ä–∞–Ω–∏—Ü—ã
        if (!canPlaceAt(entity, nx, ny)) {
            if (SHOW_AI_DEBUG) console.log('move blocked (wall) for', entity.id || entity.color || 'enemy', 'at', nx, ny);
            return false;
        }

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ –ø–µ—Ä–µ—Å–µ–∫–∞–µ—Ç—Å—è –ª–∏ —Å —è—â–∏–∫–æ–º ‚Äî —Ç–æ–≥–¥–∞ –ø–æ–ø—Ä–æ–±—É–µ–º –µ–≥–æ —Å–¥–≤–∏–Ω—É—Ç—å
        const rect = { x: nx, y: ny, w: entity.w, h: entity.h };
        const coll = getCollidingObject(rect);
        if (coll && coll.type === 'box') {
            const boxNx = coll.x + dxStep;
            const boxNy = coll.y + dyStep;
            const boxRect = { x: boxNx, y: boxNy, w: coll.w, h: coll.h };

            // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –º–æ–∂–Ω–æ –ª–∏ —Å–¥–≤–∏–Ω—É—Ç—å —è—â–∏–∫ (–Ω–µ –≤—Ä–µ–∑–∞–µ—Ç—Å—è –≤ —Å—Ç–µ–Ω—É/–¥—Ä—É–≥–æ–π –æ–±—ä–µ–∫—Ç –∏ –≤ –ø—Ä–µ–¥–µ–ª–∞—Ö –∫–∞–Ω–≤—ã)
            let blocked = false;
            if (boxRect.x < 0 || boxRect.y < 0 || boxRect.x + boxRect.w > worldWidth || boxRect.y + boxRect.h > worldHeight) blocked = true;
            for (const o of objects) {
                if (o === coll) continue;
                if (checkRectCollision(boxRect, o)) { blocked = true; break; }
            }
            if (blocked) {
                if (SHOW_AI_DEBUG) console.log('box cannot be pushed for', entity.id || entity.color || 'enemy', 'at', nx, ny);
                return false;
            }

            // –¢–æ–ª–∫–∞–µ–º —è—â–∏–∫ –Ω–∞ –æ–¥–∏–Ω —à–∞–≥
            coll.x = boxNx; coll.y = boxNy;
            spawnParticle(coll.x + coll.w / 2, coll.y + coll.h / 2);
            // –ù—É–∂–Ω–æ –ø–µ—Ä–µ—Å—Ç—Ä–æ–∏—Ç—å –Ω–∞–≤–∏–≥–∞—Ü–∏–æ–Ω–Ω—ã–π –≥—Ä–∏–¥, —Ç.–∫. –æ–±—ä–µ–∫—Ç –∏–∑–º–µ–Ω–∏–ª –ø–æ–∑–∏—Ü–∏—é
            navNeedsRebuild = true;
        }

        // –ù–∞–∫–æ–Ω–µ—Ü, –¥–≤–∏–≥–∞–µ–º —Å—É—â–Ω–æ—Å—Ç—å –Ω–∞ —à–∞–≥
        entity.x = nx; entity.y = ny;
    }
    return true;
}

// –î–æ–±–∞–≤–ª—è–µ–º —Ñ—É–Ω–∫—Ü–∏—é –¥–ª—è —Ä–∏—Å–æ–≤–∞–Ω–∏—è –æ—Ç–ª–∞–¥–æ—á–Ω—ã—Ö –ª–∏–Ω–∏–π
function drawDebugLines() {
    for (const l of debugLines) {
        ctx.beginPath();
        ctx.strokeStyle = l.color || 'red';
        ctx.lineWidth = l.width || 2;
        ctx.moveTo(l.x1, l.y1);
        ctx.lineTo(l.x2, l.y2);
        ctx.stroke();
    }
    // –æ—á–∏—â–∞–µ–º –ø–æ—Å–ª–µ —Ä–∏—Å–æ–≤–∞–Ω–∏—è
    debugLines = [];
}

function spawnParticle(x, y) {
    particles.push({
        x, y, 
        vx: (Math.random() - 0.5) * 2,
        vy: (Math.random() - 0.5) * 2,
        life: 1,
        size: Math.random() * 3 + 2
    });
}

function shoot() {
    if (tankType === 'fire') {
        // Flamethrower: emit a short cone of flame projectiles
        const flameCount = 7;
        const baseAng = tank.turretAngle;
        const spread = 0.7; // radians total cone
        for (let f = 0; f < flameCount; f++) {
            const t = flameCount <= 1 ? 0.5 : f / (flameCount - 1);
            const ang = baseAng + (t - 0.5) * spread + (Math.random() - 0.5) * 0.06;
            const sx = tank.x + tank.w/2 + Math.cos(ang) * 18;
            const sy = tank.y + tank.h/2 + Math.sin(ang) * 18;
            const speed = 3.5 + Math.random() * 1.2;
            flames.push({
                x: sx,
                y: sy,
                vx: Math.cos(ang) * speed,
                vy: Math.sin(ang) * speed,
                life: 20 + Math.floor(Math.random() * 8),
                damage: 0.22,
                team: 0
            });
        }
    } else if (tankType === 'buratino') {
        // Target in turret direction
        const dist = 300;
        const targetX = tank.x + tank.w/2 + Math.cos(tank.turretAngle) * dist;
        const targetY = tank.y + tank.h/2 + Math.sin(tank.turretAngle) * dist;
        const targetCircle = { x: targetX, y: targetY, radius: 100, color: tank.color, timer: 180, type: 'targetCircle' };
        // precompute planned explosion positions (inner 4 + outer 9) so rockets can target them
        targetCircle.planned = [];
        for (let j = 0; j < 4; j++) {
            const ang = (j / 4) * Math.PI * 2;
            const distP = targetCircle.radius * 0.3;
            targetCircle.planned.push({ x: targetCircle.x + Math.cos(ang) * distP, y: targetCircle.y + Math.sin(ang) * distP, exploded: false });
        }
        for (let j = 0; j < 9; j++) {
            const ang = (j / 9) * Math.PI * 2;
            const distP = targetCircle.radius * 0.7;
            targetCircle.planned.push({ x: targetCircle.x + Math.cos(ang) * distP, y: targetCircle.y + Math.sin(ang) * distP, exploded: false });
        }
        objects.push(targetCircle);
        tank.artilleryMode = true;
        tank.artilleryTimer = 180; // 3 seconds
        tank.fireCooldown = 60; // 1 second cooldown (60 ticks)
        // Visual rockets: spawn from tube positions but smaller and in a fan
        const rows = 3;
        const cols = Math.max(5, Math.floor((Math.min(tank.w, tank.h) * 1.5) / 10));
        const tSize = Math.min(tank.w, tank.h) * 0.35 * 1.5;
        const inset = 6;
        const usableW = tSize - inset * 2;
        const usableH = tSize - inset * 2;
        const fanSpread = 0.9; // radians total spread for the fan
        for (let r = 0; r < rows; r++) {
            const ry = -tSize/2 + inset + r * (usableH / (rows - 1 || 1));
            for (let c = 0; c < cols; c++) {
                const cx = -tSize/2 + inset + c * (usableW / (cols - 1 || 1));
                const baseAng = tank.turretAngle;
                // local tube position -> world
                const lx = cx;
                const ly = ry;
                const sx = tank.x + tank.w/2 + Math.cos(baseAng) * lx - Math.sin(baseAng) * ly;
                const sy = tank.y + tank.h/2 + Math.sin(baseAng) * lx + Math.cos(baseAng) * ly;
                // compute per-rocket fan angle offset across columns + small row offset
                const colNorm = cols <= 1 ? 0.5 : c / (cols - 1);
                const rowNorm = rows <= 1 ? 0.5 : r / (rows - 1);
                const angOffset = (colNorm - 0.5) * fanSpread + (rowNorm - 0.5) * 0.06;
                const angRocket = baseAng + angOffset + (Math.random() - 0.5) * 0.03;
                // assign rocket to one of the planned explosion positions (round-robin)
                const planned = targetCircle.planned || [];
                const idx = planned.length ? ((r * cols + c) % planned.length) : 0;
                const targetPos = planned.length ? planned[idx] : { x: targetX + Math.cos(angRocket) * (targetCircle.radius * 0.5), y: targetY + Math.sin(angRocket) * (targetCircle.radius * 0.5) };
                const dx = targetPos.x - sx;
                const dy = targetPos.y - sy;
                const delay = Math.floor((r * cols + c) * 1 + Math.random() * 2);
                const travel = Math.max(16, tank.artilleryTimer - delay - 2);
                const vx = dx / travel;
                const vy = dy / travel;
                const life = travel + 6;
                // smaller rockets targeted to planned explosion position
                objects.push({ type: 'visualRocket', x: sx, y: sy, vx: vx, vy: vy, life: life, delay: delay, w: 4, h: 3, color: '#000', angOffset: angOffset, target: targetPos });
            }
        }
    } else if (tankType === 'toxic') {
        // Toxic tank: fires projectiles straight along turret angle, they fall with gravity and explode into gas
        const speed = 7;
        const ang = tank.turretAngle;
        const sx = tank.x + tank.w/2 + Math.cos(ang) * 25;
        const sy = tank.y + tank.h/2 + Math.sin(ang) * 25;
        // fly in turret direction (both components based on angle) and do NOT have gravity
        bullets.push({
            x: sx,
            y: sy,
            w: 6,
            h: 6,
            vx: Math.cos(ang) * speed,
            vy: Math.sin(ang) * speed, // fly in turret direction
            life: 500,
            owner: 'player',
            team: 0,
            type: 'toxic',
            explodeTimer: 45, // explode after 45 ticks (~0.75 seconds)
            spawned: 5 // spawn protection for 5 ticks
        });
        tank.fireCooldown = 35; // moderate cooldown
    } else {
        const speed = 5;
        const life = 100;
        bullets.push({
            x: tank.x + tank.w/2 + Math.cos(tank.turretAngle) * 25,
            y: tank.y + tank.h/2 + Math.sin(tank.turretAngle) * 25,
            w: 4, h: 4,
            vx: Math.cos(tank.turretAngle) * speed,
            vy: Math.sin(tank.turretAngle) * speed,
            life: life,
            owner: 'player',
            team: 0,
            type: tankType
        });
    }
    if (tankType !== 'fire' && tankType !== 'buratino' && tankType !== 'toxic') {
        tank.fireCooldown = FIRE_COOLDOWN;
    }
}

function update() {
    if (gameState !== 'playing') {
        if (gameState === 'win' || gameState === 'lose') {
            if (keys['Space']) {
                location.reload();
                keys['Space'] = false;
            }
        }
        return;
    }
    if (navNeedsRebuild) { buildNavGrid(); navNeedsRebuild = false; }
    // player input only when alive
    if (tank.alive !== false) {
        if (tank.moveCooldown > 0) tank.moveCooldown--;
        let dx = 0, dy = 0;
        if (keys['KeyW']) { dy -= tank.speed; tank.baseAngle = -Math.PI/2; }
        if (keys['KeyS']) { dy += tank.speed; tank.baseAngle = Math.PI/2; }
        if (keys['KeyA']) { dx -= tank.speed; tank.baseAngle = Math.PI; }
        if (keys['KeyD']) { dx += tank.speed; tank.baseAngle = 0; }
        if (dx !== 0 || dy !== 0) {
            if (!tank.artilleryMode) {
                tank.trackOffset = (tank.trackOffset + 0.2) % 10;
                moveWithCollision(dx, 0);
                moveWithCollision(0, dy);
            }
        }
        // turret rotation with arrow keys (same effect as mouse wheel)
        if (keys['ArrowLeft']) tank.turretAngle -= 0.06;
        // Mega-gas ability (one-time per battle) for toxic tank on E
        if (tankType === 'toxic' && keys['KeyE']) {
            if (!tank.megaGasUsed) {
                // spawn a thrown mega bomb in turret direction (straight, no upward arc)
                const ang = tank.turretAngle;
                const sx = tank.x + tank.w/2 + Math.cos(ang) * 20;
                const sy = tank.y + tank.h/2 + Math.sin(ang) * 20;
                const speed = 8;
                // mega bomb flies straight along turret angle, then falls with gravity
                bullets.push({
                    x: sx,
                    y: sy,
                    w: 8,
                    h: 8,
                    vx: Math.cos(ang) * speed,
                    vy: Math.sin(ang) * speed, // fly in turret direction
                    life: 500,
                    owner: 'player',
                    team: 0,
                    type: 'megabomb',
                    explodeTimer: 60, // explode after 60 ticks (~1 second)
                    spawned: 5 // spawn protection for 5 ticks
                });
                tank.megaGasUsed = true;
            }
            keys['KeyE'] = false;
        }
        if (keys['ArrowRight']) tank.turretAngle += 0.06;
        // –ü–µ—Ä–µ–∑–∞—Ä—è–¥–∫–∞ –∏–≥—Ä–æ–∫–∞
        if (tank.fireCooldown > 0) tank.fireCooldown--;
        // –°—Ç—Ä–µ–ª—å–±–∞ (—Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –ø–µ—Ä–µ–∑–∞—Ä—è–¥–∫–∞ –∑–∞–∫–æ–Ω—á–∏–ª–∞—Å—å)
        if (keys['Space'] && tank.fireCooldown <= 0) {
            shoot();
            if (tankType !== 'fire') {
                keys['Space'] = false;
            }
        }
    }
    
    // AI –¥–ª—è –≤—Ä–∞–≥–æ–≤: –≤—ã–±–∏—Ä–∞—Ç—å –±–ª–∏–∂–∞–π—à—É—é —Ü–µ–ª—å (–∏–≥—Ä–æ–∫ –∏–ª–∏ –¥—Ä—É–≥–æ–π –≤—Ä–∞–≥) –∏ –¥–µ–π—Å—Ç–≤–æ–≤–∞—Ç—å
    for (let enemy of enemies) {
        if (!enemy || !enemy.alive) continue;
        if (enemy.paralyzed) { enemy.paralyzedTime--; if (enemy.paralyzedTime <= 0) enemy.paralyzed = false; continue; }
        
        // Check if enemy is in poison gas and escape if it's enemy poison
        let inEnemyPoison = false;
        let poisonGasPos = null;
        for (const obj of objects) {
            if (obj.type === 'gas' && obj.owner !== 'enemy') { // enemy poison = created by player/ally
                const dist = Math.hypot((enemy.x + enemy.w/2) - obj.x, (enemy.y + enemy.h/2) - obj.y);
                if (dist <= obj.radius) {
                    inEnemyPoison = true;
                    poisonGasPos = { x: obj.x, y: obj.y, radius: obj.radius };
                    break;
                }
            }
        }
        
        // If in enemy poison, try to escape
        if (inEnemyPoison && poisonGasPos) {
            // Move away from poison center
            const ex = enemy.x + enemy.w/2;
            const ey = enemy.y + enemy.h/2;
            const escapeAngle = Math.atan2(ey - poisonGasPos.y, ex - poisonGasPos.x);
            const tryDist = enemy.speed * 1.5; // move faster when escaping
            
            // Try main escape direction
            let escaped = false;
            if (moveSmallSteps(enemy, escapeAngle, tryDist)) {
                enemy.baseAngle = escapeAngle;
                escaped = true;
            } else {
                // Try sidesteps if blocked
                const sideAngles = [escapeAngle + Math.PI/3, escapeAngle - Math.PI/3, escapeAngle + Math.PI/6, escapeAngle - Math.PI/6];
                for (const a of sideAngles) {
                    if (moveSmallSteps(enemy, a, tryDist * 0.8)) {
                        enemy.baseAngle = a;
                        escaped = true;
                        break;
                    }
                }
            }
            
            // Skip normal AI behavior while escaping
            continue;
        }
        
        // –í—ã–±–æ—Ä —Ü–µ–ª–∏: –±–ª–∏–∂–∞–π—à–∞—è —Ü–µ–ª—å —Å—Ä–µ–¥–∏ –≤—Å–µ—Ö —Ç–∞–Ω–∫–æ–≤, –∏—Å–∫–ª—é—á–∞—è —Ç–µ—Ö, –∫—Ç–æ –≤ —Ç–æ–π –∂–µ –∫–æ–º–∞–Ω–¥–µ
        const otherEnemies = enemies.filter(e => e !== enemy && e.alive);
        const potentialTargets = [tank, ...allies, ...otherEnemies];
        const targets = potentialTargets.filter(t => t && (t.team === undefined || t.team !== enemy.team));
        if (targets.length === 0) continue;
        let nearest = targets[0];
        let nd = Math.hypot((nearest.x + (nearest.w||0)/2) - (enemy.x + enemy.w/2), (nearest.y + (nearest.h||0)/2) - (enemy.y + enemy.h/2));
        for (const t of targets) {
            const d = Math.hypot((t.x + (t.w||0)/2) - (enemy.x + enemy.w/2), (t.y + (t.h||0)/2) - (enemy.y + enemy.h/2));
            if (d < nd) { nearest = t; nd = d; }
        }

        // –ë–∞—à–Ω—è —Å–º–æ—Ç—Ä–∏—Ç –Ω–∞ –±–ª–∏–∂–∞–π—à—É—é —Ü–µ–ª—å
        enemy.turretAngle = Math.atan2(nearest.y - enemy.y, nearest.x - enemy.x);

        // –î–≤–∏–≥–∞—Ç—å—Å—è –∫ —Ü–µ–ª–∏ —Å –ø–æ–º–æ—â—å—é –Ω–∞–≤–∏–≥–∞—Ü–∏–æ–Ω–Ω–æ–π —Å–µ—Ç–∫–∏ (A*). –ï—Å–ª–∏ –ø—É—Ç—å –Ω–µ –Ω–∞–π–¥–µ–Ω ‚Äî –ø–∞–¥–∞–µ–º –æ–±—Ä–∞—Ç–Ω–æ –Ω–∞ –ø—Ä–µ–∂–Ω—é—é —ç–≤—Ä–∏—Å—Ç–∏–∫—É.
        const mdx = (nearest.x + (nearest.w||0)/2) - (enemy.x + enemy.w/2);
        const mdy = (nearest.y + (nearest.h||0)/2) - (enemy.y + enemy.h/2);
        const mdist = Math.hypot(mdx, mdy);
        if (mdist > 0) {
            const targetCx = nearest.x + (nearest.w||0)/2;
            const targetCy = nearest.y + (nearest.h||0)/2;
            const tryDist = enemy.speed; // per-tick movement distance

            // –ü–æ—Å—Ç—Ä–æ–∏–º/–æ–±–Ω–æ–≤–∏–º –ø—É—Ç—å –ø—Ä–∏ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏
            if (!enemy.path || !enemy.path.length || (enemy.pathRecalc || 0) <= 0) {
                const sx = enemy.x + enemy.w/2, sy = enemy.y + enemy.h/2;
                const newPath = findPath(sx, sy, targetCx, targetCy);
                if (newPath && newPath.length) {
                    enemy.path = newPath;
                    enemy.pathIndex = 0;
                    enemy.pathRecalc = 20; // —Ç–∏–∫–æ–≤ –¥–æ —Å–ª–µ–¥—É—é—â–µ–≥–æ –ø–µ—Ä–µ—Å—á—ë—Ç–∞
                } else {
                    enemy.path = [];
                    enemy.pathIndex = 0;
                    enemy.pathRecalc = 10;
                    if (SHOW_AI_DEBUG) console.log('no path found for', enemy.color || enemy.id);
                }
            } else {
                enemy.pathRecalc--;
            }

            // –ï—Å–ª–∏ –µ—Å—Ç—å –ø—É—Ç—å ‚Äî —Å–ª–µ–¥—É–µ–º –ø–æ waypoints
            // If incoming bullet detected, attempt dodge and skip normal pathing for this tick
            if (tryDodgeIncoming(enemy)) continue;

            if (enemy.path && enemy.path.length) {
                const wp = enemy.path[Math.min(enemy.pathIndex, enemy.path.length - 1)];
                const cx = enemy.x + enemy.w/2, cy = enemy.y + enemy.h/2;
                const toWpX = wp.x - cx, toWpY = wp.y - cy;
                const distToWp = Math.hypot(toWpX, toWpY);
                const ang = Math.atan2(toWpY, toWpX);
                // –î–∏—Å—Ç–∞–Ω—Ü–∏—è —à–∞–≥–∞ ‚Äî –Ω–µ –±–æ–ª—å—à–µ, —á–µ–º —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ –¥–æ —Ç–æ—á–∫–∏
                const moveDist = Math.min(tryDist, distToWp);
                // If direct path to waypoint is blocked, attempt local sidestep avoidance
                if (!pathClearFor(enemy, ang, moveDist)) {
                    const sideAngles = [ang + Math.PI/2, ang - Math.PI/2, ang + Math.PI/3, ang - Math.PI/3];
                    let avoided = false;
                    for (const a of sideAngles) {
                        if (moveSmallSteps(enemy, a, moveDist * 0.9)) { enemy.baseAngle = a; avoided = true; break; }
                    }
                    if (avoided) continue;
                    // unable to sidestep ‚Äî force path recalculation next tick
                    enemy.pathRecalc = 0;
                }
                let movedAlongPath = false;
                // –ü–æ–ø—Ä–æ–±—É–µ–º –æ—Å–Ω–æ–≤–Ω–æ–π —à–∞–≥, –∑–∞—Ç–µ–º —É–º–µ–Ω—å—à–µ–Ω–Ω—ã–µ —Ñ—Ä–∞–∫—Ü–∏–∏, —á—Ç–æ–±—ã –ø—Ä–æ–ª–µ–∑—Ç—å –≤ —É–∑–∫–∏—Ö –º–µ—Å—Ç–∞—Ö
                const fracs = [1, 0.8, 0.5];
                for (const f of fracs) {
                    if (moveSmallSteps(enemy, ang, moveDist * f)) {
                        movedAlongPath = true;
                        enemy.baseAngle = ang;
                        enemy.stuckCount = 0;
                        break;
                    }
                }
                if (movedAlongPath) {
                    if (distToWp < navCell * 0.35 || distToWp < moveDist * 1.1) {
                        enemy.pathIndex++;
                    }
                } else {
                    enemy.stuckCount = (enemy.stuckCount || 0) + 1;
                    // –µ—Å–ª–∏ –Ω–µ –º–æ–∂–µ–º –¥–≤–∏–≥–∞—Ç—å—Å—è –∫ —Ç–æ—á–∫–µ ‚Äî —Ñ–æ—Ä—Å–∏—Ä—É–µ–º –ø–µ—Ä–µ—Å—á—ë—Ç –ø—É—Ç–∏
                    if (enemy.stuckCount > 2) enemy.pathRecalc = 0;
                }
            } else {
                // fallback: —Å—Ç–∞—Ä–∞—è —ç–≤—Ä–∏—Å—Ç–∏–∫–∞ (–ª–æ–∫–∞–ª—å–Ω—ã–µ —Å—ç–º–ø–ª—ã —É–≥–ª–æ–≤)
                enemy.baseAngle = Math.atan2(mdy, mdx);
                const desiredAng = enemy.baseAngle;
                // –ü–æ–ø—ã—Ç–∫–∞ —Å–¥–µ–ª–∞—Ç—å –º–∞–ª—ã–µ —à–∞–≥–∏ –≤ –∂–µ–ª–∞–µ–º–æ–º –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–∏
                let moved = false;
                if (moveSmallSteps(enemy, desiredAng, tryDist)) {
                    moved = true;
                    enemy.baseAngle = desiredAng;
                    enemy.stuckCount = 0;
                } else {
                    const MAX_STEPS = 24;
                    const ANG_STEP = Math.PI / 24;
                    for (let s = 1; s <= MAX_STEPS && !moved; s++) {
                        const sign = (s % 2 === 0) ? 1 : -1;
                        const mag = Math.ceil(s / 2);
                        const ang = desiredAng + sign * mag * ANG_STEP;
                        if (moveSmallSteps(enemy, ang, tryDist)) {
                            moved = true; enemy.baseAngle = ang; enemy.stuckCount = 0; break;
                        } else if (SHOW_AI_DEBUG) {
                            const px1 = enemy.x + enemy.w/2; const py1 = enemy.y + enemy.h/2;
                            const px2 = px1 + Math.cos(ang) * tryDist * 4;
                            const py2 = py1 + Math.sin(ang) * tryDist * 4;
                            debugLines.push({ x1: px1, y1: py1, x2: px2, y2: py2, color: 'orange', width: 1 });
                        }
                    }
                }
                if (!moved) {
                    enemy.stuckCount = (enemy.stuckCount || 0) + 1;
                    const sidesteps = [desiredAng + Math.PI/2, desiredAng - Math.PI/2, desiredAng + Math.PI*0.6, desiredAng - Math.PI*0.6];
                    for (const ang of sidesteps) {
                        if (moveSmallSteps(enemy, ang, tryDist)) { moved = true; enemy.baseAngle = ang; enemy.stuckCount = 0; break; }
                        else if (SHOW_AI_DEBUG) { const px1 = enemy.x + enemy.w/2; const py1 = enemy.y + enemy.h/2; const px2 = px1 + Math.cos(ang) * tryDist * 4; const py2 = py1 + Math.sin(ang) * tryDist * 4; debugLines.push({ x1: px1, y1: py1, x2: px2, y2: py2, color: 'aqua', width: 1 }); }
                    }
                    if (!moved && enemy.stuckCount > 4) {
                        const newAng = desiredAng + Math.PI + (Math.random() - 0.5) * Math.PI/2;
                        if (moveSmallSteps(enemy, newAng, tryDist * 1.2)) { moved = true; enemy.baseAngle = newAng; enemy.stuckCount = 0; }
                    }
                    if (!moved) { enemy.x -= Math.cos(enemy.baseAngle) * enemy.speed * 0.25; enemy.y -= Math.sin(enemy.baseAngle) * enemy.speed * 0.25; }
                }
            }
        }

        // (–¢–æ–ª–∫–∞–Ω–∏–µ —è—â–∏–∫–æ–≤ —Ç–µ–ø–µ—Ä—å –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç—Å—è –≤–Ω—É—Ç—Ä–∏ moveSmallSteps –ø—Ä–∏ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏)

        // –°—Ç—Ä–µ–ª—è—Ç—å –ø–æ –±–ª–∏–∂–∞–π—à–µ–π —Ü–µ–ª–∏; –µ—Å–ª–∏ —Ü–µ–ª—å –≤—Ä–∞–∂–¥–µ–±–Ω–∞ (–¥—Ä—É–≥–∞—è –∫–æ–º–∞–Ω–¥–∞), —Å—Ç—Ä–µ–ª—è—Ç—å —á–∞—â–µ
        const shootProb = (nearest.team !== undefined && nearest.team !== enemy.team) ? 0.12 : 0.04;
        if (enemy.fireCooldown > 0) enemy.fireCooldown--;
        if (enemy.fireCooldown <= 0 && Math.random() < shootProb) {
            bullets.push({
                x: enemy.x + enemy.w/2 + Math.cos(enemy.turretAngle) * 25,
                y: enemy.y + enemy.h/2 + Math.sin(enemy.turretAngle) * 25,
                w: 4, h: 4,
                vx: Math.cos(enemy.turretAngle) * 6,
                vy: Math.sin(enemy.turretAngle) * 6,
                life: 100,
                owner: 'enemy',
                team: enemy.team
            });
            enemy.fireCooldown = FIRE_COOLDOWN;
        }
    }

    // AI –¥–ª—è —Å–æ—é–∑–Ω–∏–∫–æ–≤ ‚Äî –¥–µ–π—Å—Ç–≤—É—é—Ç –∫–∞–∫ –≤—Ä–∞–≥–∏, –Ω–æ —Ü–µ–ª—å —É –Ω–∏—Ö ‚Äî –≤—Ä–∞–≥–∏
    for (let ally of allies) {
        if (!ally || !ally.alive) continue;
        if (ally.paralyzed) { ally.paralyzedTime--; if (ally.paralyzedTime <= 0) ally.paralyzed = false; continue; }
        const targets = enemies.filter(e => e && e.alive);
        if (targets.length === 0) continue;
        let nearest = targets[0];
        let nd = Math.hypot((nearest.x + (nearest.w||0)/2) - (ally.x + ally.w/2), (nearest.y + (nearest.h||0)/2) - (ally.y + ally.h/2));
        for (const t of targets) {
            const d = Math.hypot((t.x + (t.w||0)/2) - (ally.x + ally.w/2), (t.y + (t.h||0)/2) - (ally.y + ally.h/2));
            if (d < nd) { nearest = t; nd = d; }
        }
        // Aim turret at nearest enemy
        ally.turretAngle = Math.atan2(nearest.y - ally.y, nearest.x - ally.x);

        // Movement towards nearest enemy (reuse enemy logic: pathfinding then small-step fallback)
        const mdx = (nearest.x + (nearest.w||0)/2) - (ally.x + ally.w/2);
        const mdy = (nearest.y + (nearest.h||0)/2) - (ally.y + ally.h/2);
        const mdist = Math.hypot(mdx, mdy);
        if (mdist > 0) {
            const targetCx = nearest.x + (nearest.w||0)/2;
            const targetCy = nearest.y + (nearest.h||0)/2;
            const tryDist = ally.speed;

            if (!ally.path || !ally.path.length || (ally.pathRecalc || 0) <= 0) {
                const sx = ally.x + ally.w/2, sy = ally.y + ally.h/2;
                const newPath = findPath(sx, sy, targetCx, targetCy);
                if (newPath && newPath.length) {
                    ally.path = newPath; ally.pathIndex = 0; ally.pathRecalc = 20;
                } else { ally.path = []; ally.pathIndex = 0; ally.pathRecalc = 10; }
            } else ally.pathRecalc--;

            // If incoming bullet detected, attempt dodge and skip normal pathing for this tick
            if (tryDodgeIncoming(ally)) continue;

            if (ally.path && ally.path.length) {
                const wp = ally.path[Math.min(ally.pathIndex, ally.path.length - 1)];
                const cx = ally.x + ally.w/2, cy = ally.y + ally.h/2;
                const toWpX = wp.x - cx, toWpY = wp.y - cy;
                const distToWp = Math.hypot(toWpX, toWpY);
                const ang = Math.atan2(toWpY, toWpX);
                const moveDist = Math.min(tryDist, distToWp);
                    // Local avoidance: if blocked, try sidesteps before forcing path recalculation
                    if (!pathClearFor(ally, ang, moveDist)) {
                        const sideAngles = [ang + Math.PI/2, ang - Math.PI/2, ang + Math.PI/3, ang - Math.PI/3];
                        let avoided = false;
                        for (const a of sideAngles) {
                            if (moveSmallSteps(ally, a, moveDist * 0.9)) { ally.baseAngle = a; avoided = true; break; }
                        }
                        if (avoided) continue;
                        ally.pathRecalc = 0;
                    }
                let movedAlongPath = false;
                const fracs = [1, 0.8, 0.5];
                for (const f of fracs) {
                    if (moveSmallSteps(ally, ang, moveDist * f)) { movedAlongPath = true; ally.baseAngle = ang; ally.stuckCount = 0; break; }
                }
                if (movedAlongPath) {
                    if (distToWp < navCell * 0.35 || distToWp < moveDist * 1.1) ally.pathIndex++;
                } else { ally.stuckCount = (ally.stuckCount || 0) + 1; if (ally.stuckCount > 2) ally.pathRecalc = 0; }
            } else {
                // fallback local sampling
                ally.baseAngle = Math.atan2(mdy, mdx);
                const desiredAng = ally.baseAngle; let moved = false;
                if (moveSmallSteps(ally, desiredAng, tryDist)) { moved = true; ally.baseAngle = desiredAng; ally.stuckCount = 0; }
                else {
                    const MAX_STEPS = 24; const ANG_STEP = Math.PI/24;
                    for (let s=1; s<=MAX_STEPS && !moved; s++) {
                        const sign = (s%2===0)?1:-1; const mag = Math.ceil(s/2); const ang = desiredAng + sign*mag*ANG_STEP;
                        if (moveSmallSteps(ally, ang, tryDist)) { moved = true; ally.baseAngle = ang; ally.stuckCount = 0; break; }
                    }
                }
                if (!moved) { ally.stuckCount = (ally.stuckCount||0) + 1; if (ally.stuckCount > 4) { const newAng = desiredAng + Math.PI + (Math.random()-0.5)*Math.PI/2; if (moveSmallSteps(ally, newAng, tryDist*1.2)) { ally.baseAngle = newAng; ally.stuckCount = 0; } } if (!moved) { ally.x -= Math.cos(ally.baseAngle)*ally.speed*0.25; ally.y -= Math.sin(ally.baseAngle)*ally.speed*0.25; } }
            }

            // Shoot at target occasionally with cooldown
            const shootProb = 0.06;
            if (ally.fireCooldown > 0) ally.fireCooldown--;
            if (ally.fireCooldown <= 0 && Math.random() < shootProb) {
                bullets.push({ x: ally.x + ally.w/2 + Math.cos(ally.turretAngle)*25, y: ally.y + ally.h/2 + Math.sin(ally.turretAngle)*25, w:4, h:4, vx:Math.cos(ally.turretAngle)*6, vy:Math.sin(ally.turretAngle)*6, life:100, owner:'ally', team: ally.team });
                ally.fireCooldown = FIRE_COOLDOWN;
            }
        }
    }
    
    // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø—É–ª—å
    for (let i = bullets.length - 1; i >= 0; i--) {
        const b = bullets[i];
        // gravity only for bullets that explicitly enable it via hasGravity
        if (b.hasGravity) {
            if (b.gravityDelay && b.gravityDelay > 0) {
                b.gravityDelay--;
            } else {
                b.vy += 0.18; // gravity
            }
        }
        b.x += b.vx;
        b.y += b.vy;
        b.life--;
        
        // Decrease spawn protection counter
        if (b.spawned > 0) b.spawned--;
        
        // Check explode timer for toxic/megabomb (only if spawn protection is done and timer is active)
        if ((b.type === 'toxic' || b.type === 'megabomb') && b.spawned <= 0) {
            if (b.explodeTimer > 0) {
                b.explodeTimer--;
                if (b.explodeTimer <= 0) {
                    explodeGas(b, b.type === 'megabomb');
                    bullets.splice(i, 1);
                    continue;
                }
            }
        }
        
        // Check if toxic bomb hit ground or went out of bounds (only if spawn protection is done)
        /* Removed ground check as toxic/megabomb no longer have gravity
        if ((b.type === 'toxic' || b.type === 'megabomb') && b.spawned <= 0 && b.y >= DISPLAY_H - 10) {
            explodeGas(b, b.type === 'megabomb');
            bullets.splice(i, 1);
            continue;
        }
        */
        
        if (b.life <= 0) {
            if (b.type === 'rocket' || b.type === 'smallRocket') explodeRocket(b);
            else if (b.type === 'toxic' || b.type === 'megabomb') explodeGas(b, b.type === 'megabomb');
            bullets.splice(i, 1);
            continue;
        }
        // normalize bullet rect (bullets stored by center)
        const bRect = { x: b.x - (b.w||0)/2, y: b.y - (b.h||0)/2, w: b.w || 4, h: b.h || 4 };
        // Check collision with objects (but toxic/megabomb pass through everything)
        let hit = false;
        if (b.type !== 'rocket' && b.type !== 'toxic' && b.type !== 'megabomb') {
            for (const obj of objects) {
                if (checkRectCollision(bRect, obj)) {
                    // Toxic/mega bombs pass through walls but explode on other objects
                    if ((b.type === 'toxic' || b.type === 'megabomb') && obj.type === 'wall') {
                        // pass through walls, don't explode
                        continue;
                    }
                    // Other bullets explode on collision, but toxic/megabomb only explode by timer
                    if (b.type !== 'toxic' && b.type !== 'megabomb') {
                        // regular explosion logic for non-toxic bullets
                    }
                    bullets.splice(i, 1);
                    hit = true;
                    if (obj.type === 'box') {
                        objects.splice(objects.indexOf(obj), 1);
                        for (let j = 0; j < 5; j++) spawnParticle(obj.x + obj.w/2, obj.y + obj.h/2);
                        navNeedsRebuild = true;
                    } else if (obj.type === 'barrel') {
                        // barrel explodes
                        explodeBarrel(obj);
                    }
                    break;
                }
            }
        }
        if (!hit) {
            // Check collision with tank (player team = 0) - toxic/megabomb only damage, don't stop
            if (tank.hp > 0 && checkRectCollision(bRect, tank) && b.team !== tank.team) {
                if (b.type === 'rocket' || b.type === 'smallRocket') {
                    explodeRocket(b);
                    bullets.splice(i, 1);
                } else if (b.type === 'toxic' || b.type === 'megabomb') {
                    // Toxic bombs only damage, don't stop or explode on contact
                    tank.hp -= 5;
                    // continue flying, don't remove bullet
                } else {
                    tank.hp -= (b.type === 'fire' ? 16 : b.type === 'rocket' ? 2 : 1);
                    bullets.splice(i, 1);
                }
                if (tank.hp <= 0) {
                    for (let k = 0; k < 30; k++) spawnParticle(tank.x + tank.w/2, tank.y + tank.h/2);
                    if (currentMode === 'war') {
                        if (tank.respawnCount >= 2) {
                            gameState = 'lose';
                        } else {
                            tank.alive = false;
                            tank.respawnTimer = 600; // 10s
                        }
                    } else {
                        gameState = 'lose';
                    }
                }
                continue;
            }
            // Check collision with allies - toxic/megabomb only damage, don't stop
            for (let j = allies.length - 1; j >= 0; j--) {
                const a = allies[j];
                if (!a || !a.alive) continue;
                if (checkRectCollision(bRect, a) && b.team !== a.team) {
                    if (b.type === 'rocket' || b.type === 'smallRocket') {
                        explodeRocket(b);
                        bullets.splice(i, 1);
                    } else if (b.type === 'toxic' || b.type === 'megabomb') {
                        // Toxic bombs only damage, don't stop or explode on contact
                        a.hp = (a.hp || 100) - 5;
                        // continue flying, don't remove bullet
                    } else {
                        a.hp = (a.hp || 100) - (b.type === 'fire' ? 16 : b.type === 'rocket' ? 2 : 1);
                        bullets.splice(i, 1);
                    }
                    if (a.hp <= 0) {
                        if (currentMode === 'war') {
                            a.alive = false; a.respawnTimer = 600; for (let k = 0; k < 8; k++) spawnParticle(a.x + a.w/2, a.y + a.h/2);
                        } else {
                            allies.splice(j, 1);
                            for (let k = 0; k < 8; k++) spawnParticle(a.x + a.w/2, a.y + a.h/2);
                        }
                    }
                    break;
                }
            }
            // Check collision with enemies - toxic/megabomb only damage, don't stop
            for (let j = enemies.length - 1; j >= 0; j--) {
                const e = enemies[j];
                if (!e || !e.alive) continue;
                if (checkRectCollision(bRect, e) && b.team !== e.team) {
                    if (b.type === 'rocket' || b.type === 'smallRocket') {
                        explodeRocket(b);
                        bullets.splice(i, 1);
                    } else if (b.type === 'toxic' || b.type === 'megabomb') {
                        // Toxic bombs only damage, don't stop or explode on contact
                        e.hp -= 5;
                        // continue flying, don't remove bullet
                    } else {
                        e.hp -= (b.type === 'fire' ? 16 : b.type === 'rocket' ? 2 : 1);
                        if (b.type === 'ice') { e.paralyzed = true; e.paralyzedTime = 180; }
                        bullets.splice(i, 1);
                    }
                    if (e.hp <= 0) {
                        coins += 5; // earn coins for killing enemy
                        if (currentMode === 'war') {
                            e.alive = false; e.respawnTimer = 600; for (let k = 0; k < 10; k++) spawnParticle(e.x + e.w/2, e.y + e.h/2);
                        } else {
                            enemies.splice(j, 1);
                            for (let k = 0; k < 10; k++) spawnParticle(e.x + e.w/2, e.y + e.h/2);
                        }
                    }
                    break;
                }
            }
        }
    }
    
    // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –æ–≥–Ω–µ–Ω–Ω—ã—Ö —á–∞—Å—Ç–∏—Ü
    for (let i = flames.length - 1; i >= 0; i--) {
        const f = flames[i];
        f.x += f.vx;
        f.y += f.vy;
        f.life--;
        if (f.life <= 0) {
            flames.splice(i, 1);
            continue;
        }
        // Check collision with objects
        let hit = false;
        for (const obj of objects) {
            if (checkRectCollision({x: f.x-2, y: f.y-2, w:4, h:4}, obj)) {
                flames.splice(i, 1);
                hit = true;
                if (obj.type === 'box') {
                    objects.splice(objects.indexOf(obj), 1);
                    for (let j = 0; j < 5; j++) spawnParticle(obj.x + obj.w/2, obj.y + obj.h/2);
                    navNeedsRebuild = true;
                } else if (obj.type === 'barrel') {
                    explodeBarrel(obj);
                }
                break;
            }
        }
        if (!hit) {
            // Check collision with tank
            if (tank.hp > 0 && checkRectCollision({x: f.x-2, y: f.y-2, w:4, h:4}, tank) && f.team !== tank.team) {
                tank.hp -= f.damage;
                flames.splice(i, 1);
                if (tank.hp <= 0) {
                    for (let k = 0; k < 30; k++) spawnParticle(tank.x + tank.w/2, tank.y + tank.h/2);
                    if (currentMode === 'war') {
                        if (tank.respawnCount >= 2) {
                            gameState = 'lose';
                        } else {
                            tank.alive = false;
                            tank.respawnTimer = 600;
                        }
                    } else {
                        gameState = 'lose';
                    }
                }
                continue;
            }
            // Check collision with allies
            for (let j = allies.length - 1; j >= 0; j--) {
                const a = allies[j];
                if (!a || !a.alive) continue;
                if (checkRectCollision({x: f.x-2, y: f.y-2, w:4, h:4}, a) && f.team !== a.team) {
                    a.hp -= f.damage;
                    flames.splice(i, 1);
                    if (a.hp <= 0) {
                        if (currentMode === 'war') {
                            a.alive = false; a.respawnTimer = 600; for (let k = 0; k < 8; k++) spawnParticle(a.x + a.w/2, a.y + a.h/2);
                        } else {
                            allies.splice(j, 1);
                            for (let k = 0; k < 8; k++) spawnParticle(a.x + a.w/2, a.y + a.h/2);
                        }
                    }
                    break;
                }
            }
            // Check collision with enemies
            for (let j = enemies.length - 1; j >= 0; j--) {
                const e = enemies[j];
                if (!e || !e.alive) continue;
                if (checkRectCollision({x: f.x-2, y: f.y-2, w:4, h:4}, e) && f.team !== e.team) {
                    e.hp -= f.damage;
                    flames.splice(i, 1);
                    if (e.hp <= 0) {
                        coins += 5;
                        if (currentMode === 'war') {
                            e.alive = false; e.respawnTimer = 600; for (let k = 0; k < 10; k++) spawnParticle(e.x + e.w/2, e.y + e.h/2);
                        } else {
                            enemies.splice(j, 1);
                            for (let k = 0; k < 10; k++) spawnParticle(e.x + e.w/2, e.y + e.h/2);
                        }
                    }
                    break;
                }
            }
        }
    }
    
    // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ target circles
    for (let i = objects.length - 1; i >= 0; i--) {
        const obj = objects[i];
        if (obj.type === 'targetCircle') {
            obj.timer--;
            if (obj.timer <= 0) {
                // use global applyDamage(x,y) helper for area damage
                // If planned positions exist, only spawn explosions for positions not yet exploded.
                if (obj.planned && obj.planned.length) {
                    for (let p of obj.planned) {
                        if (!p.exploded) {
                            objects.push({ type: 'explosion', x: p.x, y: p.y, radius: 30, life: 30, color: '#FFA500' });
                            applyDamage(p.x, p.y);
                        }
                    }
                } else {
                    // fallback: spawn original pattern
                    for (let j = 0; j < 4; j++) {
                        const ang = (j / 4) * Math.PI * 2;
                        const dist = obj.radius * 0.3;
                        const ex = obj.x + Math.cos(ang) * dist;
                        const ey = obj.y + Math.sin(ang) * dist;
                        objects.push({ type: 'explosion', x: ex, y: ey, radius: 30, life: 30, color: '#FFA500' });
                        applyDamage(ex, ey);
                    }
                    for (let j = 0; j < 9; j++) {
                        const ang = (j / 9) * Math.PI * 2;
                        const dist = obj.radius * 0.7;
                        const ex = obj.x + Math.cos(ang) * dist;
                        const ey = obj.y + Math.sin(ang) * dist;
                        objects.push({ type: 'explosion', x: ex, y: ey, radius: 30, life: 30, color: '#FFA500' });
                        applyDamage(ex, ey);
                    }
                }
                objects.splice(i, 1);
            }
        } else if (obj.type === 'explosion') {
            obj.life--;
            if (obj.life <= 0) objects.splice(i, 1);
        } else if (obj.type === 'gas') {
            // gas cloud visual fades over time
            obj.life--;
            if (obj.life <= 0) objects.splice(i, 1);
        } else if (obj.type === 'visualRocket') {
            // visual rocket supports an initial delay (stay at tube), then fly, leave a trail, and explode on arrival
            if (obj.delay && obj.delay > 0) {
                obj.delay--;
                if (obj.delay === 0) spawnParticle(obj.x, obj.y);
            } else {
                obj.x += obj.vx;
                obj.y += obj.vy;
                // small smoke trail
                if (Math.random() < 0.6) {
                    particles.push({ x: obj.x, y: obj.y, vx: (Math.random() - 0.5) * 0.4 - obj.vx * 0.08, vy: (Math.random() - 0.5) * 0.4 - obj.vy * 0.08, life: 8, size: 2, color: 'rgba(80,80,80,0.6)' });
                }

                // If rocket has an assigned planned target, detonate precisely at that planned spot
                let exploded = false;
                if (obj.target) {
                    const distToTarget = Math.hypot(obj.x - obj.target.x, obj.y - obj.target.y);
                    if (distToTarget <= 10) {
                        // spawn explosion at planned spot and mark it
                        objects.push({ type: 'explosion', x: obj.target.x, y: obj.target.y, radius: 30, life: 30, color: '#FFA500' });
                        obj.target.exploded = true;
                        applyDamage(obj.target.x, obj.target.y);
                        exploded = true;
                    }
                } else {
                    // fallback: if no assigned target, explode when entering any targetCircle
                    for (let j = 0; j < objects.length; j++) {
                        const o = objects[j];
                        if (o.type === 'targetCircle') {
                            const dist = Math.hypot(obj.x - o.x, obj.y - o.y);
                            if (dist <= o.radius + 6) {
                                objects.push({ type: 'explosion', x: obj.x, y: obj.y, radius: 30, life: 30, color: '#FFA500' });
                                applyDamage(obj.x, obj.y);
                                exploded = true;
                                break;
                            }
                        }
                    }
                }

                obj.life--;
                if (exploded || obj.life <= 0) {
                    // remove rocket
                    objects.splice(i, 1);
                }
            }
        }
    }
    
    // Check artillery mode
    if (tank.artilleryTimer > 0) {
        tank.artilleryTimer--;
        if (tank.artilleryTimer <= 0) tank.artilleryMode = false;
    }
    
    // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —á–∞—Å—Ç–∏—Ü
    for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.x += p.vx; p.y += p.vy;
        p.life -= 0.02;
        if (p.life <= 0) particles.splice(i, 1);
    }

    // Apply gas effects: check entities entering gas clouds and apply poison timers
    const GAS_DEBUFF_TICKS = 3 * 60; // 3 seconds
    for (const obj of objects) {
        if (obj.type !== 'gas') continue;
        // Only poison enemies if gas was created by player
        if (obj.owner === 'player') {
            // enemies
            for (const e of enemies) {
                if (!e || !e.alive) continue;
                const dist = Math.hypot((e.x + (e.w||0)/2) - obj.x, (e.y + (e.h||0)/2) - obj.y);
                if (dist <= obj.radius) {
                    if (!e.poisonTimer || e.poisonTimer <= 0) e.poisonTimer = GAS_DEBUFF_TICKS;
                }
            }
        } else if (obj.owner === 'ally') {
            // Only poison enemies if gas was created by an ally
            for (const e of enemies) {
                if (!e || !e.alive) continue;
                const dist = Math.hypot((e.x + (e.w||0)/2) - obj.x, (e.y + (e.h||0)/2) - obj.y);
                if (dist <= obj.radius) {
                    if (!e.poisonTimer || e.poisonTimer <= 0) e.poisonTimer = GAS_DEBUFF_TICKS;
                }
            }
        } else if (obj.owner === 'enemy') {
            // Only poison player and allies if gas was created by an enemy
            if (tank.alive !== false) {
                const dist = Math.hypot((tank.x + tank.w/2) - obj.x, (tank.y + tank.h/2) - obj.y);
                if (dist <= obj.radius) {
                    if (!tank.poisonTimer || tank.poisonTimer <= 0) tank.poisonTimer = GAS_DEBUFF_TICKS;
                }
            }
            for (const a of allies) {
                if (!a || !a.alive) continue;
                const dist = Math.hypot((a.x + (a.w||0)/2) - obj.x, (a.y + (a.h||0)/2) - obj.y);
                if (dist <= obj.radius) {
                    if (!a.poisonTimer || a.poisonTimer <= 0) a.poisonTimer = GAS_DEBUFF_TICKS;
                }
            }
        }
    }

    // Apply poison damage over time to all entities with poisonTimer
    const applyPoisonTick = (ent) => {
        if (!ent || !ent.poisonTimer) return;
        if (ent.alive === false) return; // Don't poison dead entities
        if (ent.poisonTimer > 0) {
            // damage = (maxHp or 3) / 6 per second -> per tick divide by 60
            const maxHp = ent.maxHp || 3;
            const dmgPerSec = maxHp / 6;
            const dmgPerTick = dmgPerSec / 60;
            ent.hp = (ent.hp || 0) - dmgPerTick;
            ent.poisonTimer--;
            if (ent.hp <= 0) {
                ent.hp = 0;
                ent.alive = false;
            }
        }
    };
    applyPoisonTick(tank);
    
    // Allies poison check
    for (let i = allies.length - 1; i >= 0; i--) {
        const a = allies[i];
        applyPoisonTick(a);
        if (a.hp <= 0 && a.alive === false) {
             if (currentMode === 'war') {
                 if (!a.respawnTimer) {
                     a.respawnTimer = 600;
                     for (let k = 0; k < 8; k++) spawnParticle(a.x + a.w/2, a.y + a.h/2);
                 }
             } else {
                 allies.splice(i, 1);
                 for (let k = 0; k < 8; k++) spawnParticle(a.x + a.w/2, a.y + a.h/2);
             }
        }
    }
    
    // Enemies poison check
    for (let i = enemies.length - 1; i >= 0; i--) {
        const e = enemies[i];
        applyPoisonTick(e);
        if (e.hp <= 0 && e.alive === false) {
             if (currentMode === 'war') {
                 if (!e.respawnTimer) {
                     e.respawnTimer = 600;
                     for (let k = 0; k < 10; k++) spawnParticle(e.x + e.w/2, e.y + e.h/2);
                 }
             } else {
                 if (currentMode === 'single' || currentMode === 'team') coins += 5; // Reward
                 enemies.splice(i, 1);
                 for (let k = 0; k < 10; k++) spawnParticle(e.x + e.w/2, e.y + e.h/2);
             }
        }
    }

    // Respawn timers (War mode): decrement and respawn if team still has members
    if (currentMode === 'war') {
        // player
        if (tank.alive === false && tank.respawnTimer > 0) {
            tank.respawnTimer--;
            if (tank.respawnTimer <= 0) {
                if (tank.respawnCount < 2) {
                    // respawn near team spawn
                    const sp = (warTeamSpawns[0]) ? warTeamSpawns[0] : { x: 120, y: 120 };
                    const p = findFreeSpot(sp.x - 40 + Math.random()*80, sp.y - 40 + Math.random()*80, tank.w, tank.h, 600, 24);
                    tank.x = p.x; tank.y = p.y; tank.hp = 3; tank.alive = true; tank.respawnTimer = 0; tank.respawnCount++;
                }
            }
        }
        // allies
        for (const a of allies) {
            if (!a) continue;
            if (a.alive === false && (a.respawnTimer || 0) > 0) {
                a.respawnTimer--;
                if (a.respawnTimer <= 0) {
                    if (teamHasAliveMember(a.team) && (a.respawnCount || 0) < 2) {
                        const sp = warTeamSpawns[a.team] || { x: 120, y: 120 };
                        const p = findFreeSpot(sp.x + (Math.random()-0.5)*160, sp.y + (Math.random()-0.5)*160, a.w, a.h, 600, 24);
                        a.x = p.x; a.y = p.y; a.hp = 3; a.alive = true; a.respawnTimer = 0; a.respawnCount = (a.respawnCount || 0) + 1;
                    }
                }
            }
        }
        // enemies
        for (const e of enemies) {
            if (!e) continue;
            if (e.alive === false && (e.respawnTimer || 0) > 0) {
                e.respawnTimer--;
                if (e.respawnTimer <= 0) {
                    if (teamHasAliveMember(e.team) && (e.respawnCount || 0) < 2) {
                        const sp = warTeamSpawns[e.team] || { x: worldWidth - 120, y: worldHeight - 120 };
                        const p = findFreeSpot(sp.x + (Math.random()-0.5)*160, sp.y + (Math.random()-0.5)*160, e.w, e.h, 600, 24);
                        e.x = p.x; e.y = p.y; e.hp = 3; e.alive = true; e.respawnTimer = 0; e.respawnCount = (e.respawnCount || 0) + 1;
                    }
                }
            }
        }
    }

    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ–±–µ–¥—ã/–ø–æ—Ä–∞–∂–µ–Ω–∏—è
    if (currentMode === 'war') {
        const aliveEnemies = enemies.filter(e => e && e.alive !== false && e.hp > 0);
        if (aliveEnemies.length === 0) {
            gameState = 'win';
            coins += 50; // reward for war
        }
    } else if (enemies.length === 0) {
        gameState = 'win';
        if (currentMode === 'single') coins += 25;
        else if (currentMode === 'team') coins += 40;
    }
}

function moveWithCollision(dx, dy) {
    tank.x += dx;
    tank.y += dy;

    for (const obj of objects) {
        if (checkRectCollision(tank, obj)) {
            if (obj.type === 'box' || obj.type === 'barrel') {
                // –ü—ã—Ç–∞–µ–º—Å—è —Ç–æ–ª–∫–∞—Ç—å —è—â–∏–∫
                obj.x += dx;
                obj.y += dy;
                
                const blocked = objects.some(o => o !== obj && checkRectCollision(obj, o)) ||
                                obj.x < 0 || obj.y < 0 || 
                                obj.x + obj.w > worldWidth || obj.y + obj.h > worldHeight;
                
                if (blocked) {
                    obj.x -= dx; obj.y -= dy;
                    tank.x -= dx; tank.y -= dy;
                } else if (dx !== 0 || dy !== 0) {
                    spawnParticle(obj.x + obj.w/2, obj.y + obj.h/2);
                }
            } else {
                // –ñ–µ—Å—Ç–∫–∞—è —Å—Ç–µ–Ω–∞
                tank.x -= dx;
                tank.y -= dy;
            }
        }
    }
    
    // –ö—Ä–∞—è –º–∏—Ä–∞
    tank.x = Math.max(0, Math.min(worldWidth - tank.w, tank.x));
    tank.y = Math.max(0, Math.min(worldHeight - tank.h, tank.y));
}

/**
 * –û–¢–†–ò–°–û–í–ö–ê –ì–†–ê–§–ò–ö–ò
 */
function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    // ensure normal drawing mode
    ctx.globalCompositeOperation = 'source-over';
    // Camera follow: translate so player is centered when enabled
    let cameraTranslated = false;
    if (cameraFollow) {
        const offsetX = canvas.width/2 - (tank.x + tank.w/2);
        const offsetY = canvas.height/2 - (tank.y + tank.h/2);
        ctx.save();
        ctx.translate(offsetX, offsetY);
        cameraTranslated = true;
    }

    // 1. –§–æ–Ω (—Å–µ—Ç–∫–∞) ‚Äî cell grid aligned to nav cells (visible window only)
    ctx.strokeStyle = 'rgba(0,0,0,0.15)';
    ctx.lineWidth = 1;
    const gridStep = navCell;
    // compute visible world bounds in world coordinates
    let visX = 0, visY = 0;
    if (cameraFollow) {
        visX = tank.x + tank.w/2 - canvas.width/2;
        visY = tank.y + tank.h/2 - canvas.height/2;
    } else {
        visX = 0; visY = 0;
    }
    const minX = Math.max(0, Math.floor(visX / gridStep) * gridStep);
    const minY = Math.max(0, Math.floor(visY / gridStep) * gridStep);
    const maxX = Math.min(worldWidth, visX + canvas.width);
    const maxY = Math.min(worldHeight, visY + canvas.height);
    for (let x = minX; x <= maxX; x += gridStep) {
        ctx.beginPath(); ctx.moveTo(x, minY); ctx.lineTo(x, maxY); ctx.stroke();
    }
    for (let y = minY; y <= maxY; y += gridStep) {
        ctx.beginPath(); ctx.moveTo(minX, y); ctx.lineTo(maxX, y); ctx.stroke();
    }

    // 2. –ß–∞—Å—Ç–∏—Ü—ã –ø—ã–ª–∏
    particles.forEach(p => {
        ctx.fillStyle = p.color || `rgba(139, 69, 19, ${p.life})`;
        ctx.fillRect(p.x, p.y, p.size, p.size);
    });

    // 3. –û–±—ä–µ–∫—Ç—ã
    objects.forEach(obj => {
        ctx.save();
        ctx.fillStyle = obj.color;
        if (obj.type === 'wall') {
            ctx.shadowBlur = 5; ctx.shadowColor = 'black';
            ctx.fillRect(obj.x, obj.y, obj.w, obj.h);
            ctx.shadowBlur = 0;
            // –ö–∏—Ä–ø–∏—á–Ω—ã–π —É–∑–æ—Ä
            ctx.strokeStyle = 'rgba(255,255,255,0.1)';
            ctx.strokeRect(obj.x, obj.y, obj.w, obj.h);
        } else if (obj.type === 'barrel') {
            // brown metallic barrel: cylindrical body, steel bands and highlights
            const cx = obj.x + obj.w/2;
            const cy = obj.y + obj.h/2;
            const rx = obj.w/2;
            const ry = Math.max(6, obj.h * 0.18);

            // metallic vertical gradient (dark -> mid -> highlight -> dark)
            const grad = ctx.createLinearGradient(obj.x, obj.y, obj.x, obj.y + obj.h);
            grad.addColorStop(0, '#4b2b17');
            grad.addColorStop(0.45, '#7a4d2a');
            grad.addColorStop(0.55, '#c27f48');
            grad.addColorStop(1, '#5a2f18');
            ctx.fillStyle = grad;
            // body (leave small top/bottom for ellipses)
            ctx.fillRect(obj.x, obj.y + ry * 0.5, obj.w, obj.h - ry);

            // top ellipse (slightly darker rim)
            ctx.beginPath();
            ctx.ellipse(cx, obj.y + ry * 0.6, rx * 0.92, ry * 0.9, 0, 0, Math.PI * 2);
            ctx.fillStyle = '#6b361b';
            ctx.fill();
            ctx.strokeStyle = 'rgba(0,0,0,0.35)'; ctx.lineWidth = 2; ctx.stroke();

            // steel bands (two rings) with slight specular
            const bandH = Math.max(4, obj.h * 0.08);
            const bandY1 = obj.y + obj.h * 0.28;
            const bandY2 = obj.y + obj.h * 0.62;
            ctx.fillStyle = '#33363a'; ctx.fillRect(obj.x, bandY1, obj.w, bandH);
            ctx.fillStyle = '#2b2f34'; ctx.fillRect(obj.x, bandY2, obj.w, bandH);
            // thin highlight on top edge of rings
            ctx.fillStyle = 'rgba(255,255,255,0.12)';
            ctx.fillRect(obj.x, bandY1 + 1, obj.w, 1);
            ctx.fillRect(obj.x, bandY2 + 1, obj.w, 1);

            // rivets on bands
            ctx.fillStyle = 'rgba(220,220,220,0.6)';
            const rivetCount = Math.max(3, Math.floor(obj.w / 40));
            for (let r = 0; r < rivetCount; r++) {
                const rxpos = obj.x + 8 + (r / (rivetCount - 1)) * (obj.w - 16);
                ctx.beginPath(); ctx.arc(rxpos, bandY1 + bandH/2, 2, 0, Math.PI*2); ctx.fill();
                ctx.beginPath(); ctx.arc(rxpos, bandY2 + bandH/2, 2, 0, Math.PI*2); ctx.fill();
            }

            // vertical specular highlight (curved)
            ctx.beginPath();
            ctx.moveTo(obj.x + obj.w * 0.18, obj.y + obj.h * 0.12);
            ctx.quadraticCurveTo(obj.x + obj.w * 0.23, obj.y + obj.h * 0.5, obj.x + obj.w * 0.18, obj.y + obj.h * 0.88);
            ctx.strokeStyle = 'rgba(255,255,255,0.12)'; ctx.lineWidth = Math.max(2, obj.w * 0.06); ctx.stroke();

            // subtle top gloss (radial)
            const radial = ctx.createRadialGradient(cx, obj.y + ry*0.6, 2, cx, obj.y + ry*0.6, rx*1.1);
            radial.addColorStop(0, 'rgba(255,255,255,0.22)');
            radial.addColorStop(0.25, 'rgba(255,255,255,0.06)');
            radial.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = radial;
            ctx.beginPath(); ctx.ellipse(cx, obj.y + ry * 0.6, rx * 0.9, ry * 0.9, 0, 0, Math.PI * 2); ctx.fill();

            // bottom shadow ellipse
            ctx.beginPath();
            ctx.ellipse(cx, obj.y + obj.h - ry * 0.35, rx * 0.9, ry * 0.6, 0, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(0,0,0,0.22)';
            ctx.fill();
        } else if (obj.type === 'targetCircle') {
            ctx.strokeStyle = obj.color;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(obj.x, obj.y, obj.radius, 0, Math.PI * 2);
            ctx.stroke();
        } else if (obj.type === 'explosion') {
            ctx.globalAlpha = obj.life / 30;
            ctx.fillStyle = obj.color;
            ctx.beginPath();
            ctx.arc(obj.x, obj.y, obj.radius * (1 - obj.life / 30), 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1;
        } else if (obj.type === 'visualRocket') {
            // draw visual rocket as small black rectangle oriented by velocity
            ctx.save();
            ctx.translate(obj.x, obj.y);
            const ang = Math.atan2(obj.vy, obj.vx);
            ctx.rotate(ang);
            ctx.fillStyle = obj.color || '#000';
            ctx.fillRect(-obj.w/2, -obj.h/2, obj.w, obj.h);
            ctx.restore();
        } else if (obj.type === 'gas') {
            // draw gas as soft green circle with alpha based on remaining life
            const alpha = Math.max(0.06, obj.life / obj.maxLife * 0.6);
            ctx.fillStyle = `rgba(60,180,60,${alpha})`;
            ctx.beginPath(); ctx.arc(obj.x, obj.y, obj.radius, 0, Math.PI * 2); ctx.fill();
            // subtle inner glow
            ctx.fillStyle = `rgba(120,240,120,${alpha * 0.25})`;
            ctx.beginPath(); ctx.arc(obj.x, obj.y, obj.radius * 0.6, 0, Math.PI * 2); ctx.fill();
        } else {
            // –Ø—â–∏–∫
            ctx.fillRect(obj.x, obj.y, obj.w, obj.h);
            ctx.strokeStyle = '#5a361a';
            ctx.lineWidth = 3;
            ctx.strokeRect(obj.x + 5, obj.y + 5, obj.w - 10, obj.h - 10);
            ctx.beginPath();
            ctx.moveTo(obj.x, obj.y); ctx.lineTo(obj.x+obj.w, obj.y+obj.h);
            ctx.moveTo(obj.x+obj.w, obj.y); ctx.lineTo(obj.x, obj.y+obj.h);
            ctx.stroke();
        }
        ctx.restore();
    });

    // 3.5. –ü—É–ª–∏
    bullets.forEach(b => {
        if (b.type === 'fire') {
            ctx.strokeStyle = '#FF4500';
            ctx.lineWidth = 6;
            ctx.beginPath();
            ctx.moveTo(b.x, b.y);
            ctx.lineTo(b.x - b.vx * 5, b.y - b.vy * 5);
            ctx.stroke();
        } else if (b.type === 'rocket') {
            ctx.fillStyle = '#FF0000';
            ctx.fillRect(b.x - b.w/2, b.y - b.h/2, b.w, b.h);
        } else if (b.type === 'smallRocket') {
            ctx.fillStyle = '#000000';
            ctx.fillRect(b.x - b.w/2, b.y - b.h/2, b.w, b.h);
        } else {
            ctx.fillStyle = '#ffff00';
            ctx.fillRect(b.x - b.w/2, b.y - b.h/2, b.w, b.h);
        }
    });

    // 3.6. –û–≥–Ω–µ–Ω–Ω—ã–µ —á–∞—Å—Ç–∏—Ü—ã
    flames.forEach(f => {
        ctx.fillStyle = '#FF4500';
        ctx.fillRect(f.x - 2, f.y - 2, 4, 4);
    });

    // reset any drawing state that object rendering might have changed
    ctx.shadowBlur = 0;
    ctx.shadowColor = 'transparent';
    ctx.globalCompositeOperation = 'source-over';
    ctx.globalAlpha = 1;

    // –ù–∞—Ä–∏—Å–æ–≤–∞—Ç—å –ª–∏–Ω–∏–∏ –æ—Ç–ª–∞–¥–∫–∏ AI (–µ—Å–ª–∏ –≤–∫–ª—é—á–µ–Ω–æ)
    if (SHOW_AI_DEBUG) drawDebugLines();

    // 4. –í—Ä–∞–≥–∏
    // Allies (friendly bots)
    allies.forEach(a => {
        if (!a || !a.alive) return;
        ctx.save();
        ctx.translate(a.x + a.w/2, a.y + a.h/2);
        ctx.fillStyle = '#222';
        ctx.fillRect(-a.w/2, -a.h/2 - 4, a.w, 8);
        ctx.fillRect(-a.w/2, a.h/2 - 4, a.w, 8);
        ctx.fillStyle = a.paralyzed ? '#00FFFF' : (a.color || '#888');
        ctx.fillRect(-a.w/2 + 4, -a.h/2 + 2, a.w - 8, a.h - 4);
        ctx.rotate(a.turretAngle || 0);
        ctx.fillStyle = '#5c7041'; ctx.fillRect(-12, -12, 24, 24);
        ctx.fillStyle = '#111'; ctx.fillRect(0, -3, 35, 6);
        ctx.restore();
        // small ally tag
        ctx.fillStyle = 'white'; ctx.font = '10px Arial'; ctx.textAlign = 'center';
        ctx.fillText('ALLY', a.x + a.w/2, a.y - 14);
    });

    enemies.forEach(enemy => {
        if (!enemy || !enemy.alive) return;
        ctx.save();
        ctx.translate(enemy.x + enemy.w/2, enemy.y + enemy.h/2);
        // –ì—É—Å–µ–Ω–∏—Ü—ã (–≤–µ—Ä—Ö/–Ω–∏–∑)
        ctx.fillStyle = '#222';
        ctx.fillRect(-enemy.w/2, -enemy.h/2 - 4, enemy.w, 8);
        ctx.fillRect(-enemy.w/2, enemy.h/2 - 4, enemy.w, 8);
        // –ö–æ—Ä–ø—É—Å
        ctx.fillStyle = enemy.paralyzed ? '#00FFFF' : enemy.color;
        ctx.fillRect(-enemy.w/2 + 4, -enemy.h/2 + 2, enemy.w - 8, enemy.h - 4);
        // –ë–∞—à–Ω—è
        ctx.rotate(enemy.turretAngle);
        ctx.fillStyle = '#5c7041';
        ctx.fillRect(-12, -12, 24, 24);
        ctx.fillStyle = '#111';
        ctx.fillRect(0, -3, 35, 6);
        ctx.fillRect(32, -4, 5, 8);
        ctx.restore();
        // HP bar
        ctx.fillStyle = 'red';
        ctx.fillRect(enemy.x, enemy.y - 10, enemy.w, 5);
        ctx.fillStyle = 'green';
        ctx.fillRect(enemy.x, enemy.y - 10, enemy.w * (enemy.hp / 3), 5);
    });

    // 5. –¢–∞–Ω–∫
    if (tank.alive !== false) {
        ctx.save();
        ctx.translate(tank.x + tank.w/2, tank.y + tank.h/2);
        drawTankOn(ctx, 0, 0, tank.w, tank.h, tank.color, tank.turretAngle, 1, tankType);
        ctx.restore();
        // HP bar –¥–ª—è –∏–≥—Ä–æ–∫–∞
        ctx.fillStyle = 'red';
        ctx.fillRect(tank.x, tank.y - 10, tank.w, 5);
        ctx.fillStyle = 'green';
        ctx.fillRect(tank.x, tank.y - 10, tank.w * (tank.hp / 3), 5);
    }
    // restore camera transform before drawing UI/modal overlays
    if (cameraTranslated) ctx.restore();

    // show respawn countdown for player if dead in war
    if (tank.alive === false && currentMode === 'war' && tank.respawnTimer > 0 && gameState !== 'lose') {
        ctx.fillStyle = 'white'; ctx.font = '18px Arial'; ctx.textAlign = 'center';
        ctx.fillText('Respawn in ' + Math.ceil(tank.respawnTimer / 60) + 's', canvas.width/2, 40);
    }

    // –ú–æ–¥–∞–ª—å–Ω—ã–µ –æ–∫–Ω–∞
    if (gameState === 'menu') {
        // –∑–∞—Ç–µ–º–Ω—è–µ–º —Ñ–æ–Ω
        ctx.fillStyle = 'rgba(0,0,0,0.6)';
        ctx.fillRect(0,0,canvas.width, canvas.height);
        // –Ω–µ–º–Ω–æ–≥–æ —Ç–µ–∫—Å—Ç–∞, –Ω–æ –æ—Å–Ω–æ–≤–Ω–æ–µ –º–µ–Ω—é ‚Äî DOM-—ç–ª–µ–º–µ–Ω—Ç –ø–æ–≤–µ—Ä—Ö
    } else if (gameState === 'win') {
        ctx.fillStyle = 'rgba(0,0,0,0.7)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = 'white';
        ctx.font = '48px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('YOU WIN!', canvas.width / 2, canvas.height / 2);
        ctx.font = '24px Arial';
        ctx.fillText('Press SPACE to restart', canvas.width / 2, canvas.height / 2 + 50);
    } else if (gameState === 'lose') {
        ctx.fillStyle = 'rgba(0,0,0,0.7)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = 'white';
        ctx.font = '48px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('YOU LOSE!', canvas.width / 2, canvas.height / 2);
        ctx.font = '24px Arial';
        ctx.fillText('Press SPACE to restart', canvas.width / 2, canvas.height / 2 + 50);
    }

    // draw preview inside menu DOM as well
    drawPreview();

    updateCoinDisplay();

    requestAnimationFrame(draw);
}

// Update coin display
function updateCoinDisplay() {
    const coinDisplay = document.getElementById('coinDisplay');
    if (coinDisplay) coinDisplay.textContent = coins;
    localStorage.setItem('tankCoins', coins);
}

// Make draw globally available (ensure load handler can call it)
window.draw = draw;

// –ü–æ—Å—Ç–æ—è–Ω–Ω—ã–π —Ü–∏–∫–ª –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Ñ–∏–∑–∏–∫–∏
setInterval(update, 1000/60);

// –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø–æ—Å–ª–µ –∑–∞–≥—Ä—É–∑–∫–∏ —Å—Ç—Ä–∞–Ω–∏—Ü—ã ‚Äî –∑–∞—â–∏—â–∞–µ–º –æ—Ç —Ä–∞–Ω–Ω–∏—Ö –æ—à–∏–±–æ–∫
window.addEventListener('load', () => {
    try {
        console.log('Game init');
        generateMap();
        // draw() may be block-scoped in some environments; retry until available
        const tryStart = () => {
            if (typeof draw === 'function') {
                draw();
            } else {
                console.warn('draw not ready, retrying');
                setTimeout(tryStart, 50);
            }
        };
        tryStart();
    } catch (err) {
        console.error('Init error', err);
    }
});

// Draw character previews on load
drawCharacterPreviews();

</script>
</body>
</html>
